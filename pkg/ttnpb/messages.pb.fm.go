// Code generated by protoc-gen-fieldmask. DO NOT EDIT.

package ttnpb

import (
	fmt "fmt"
	time "time"
)

var UplinkMessageFieldPathsNested = []string{
	"Payload",
	"correlation_ids",
	"end_device_ids",
	"end_device_ids.application_ids",
	"end_device_ids.application_ids.application_id",
	"end_device_ids.dev_addr",
	"end_device_ids.dev_eui",
	"end_device_ids.device_id",
	"end_device_ids.join_eui",
	"payload",
	"payload.Payload.join_accept_payload",
	"payload.Payload.join_accept_payload.cf_list",
	"payload.Payload.join_accept_payload.cf_list.ch_masks",
	"payload.Payload.join_accept_payload.cf_list.freq",
	"payload.Payload.join_accept_payload.cf_list.type",
	"payload.Payload.join_accept_payload.dev_addr",
	"payload.Payload.join_accept_payload.dl_settings",
	"payload.Payload.join_accept_payload.dl_settings.opt_neg",
	"payload.Payload.join_accept_payload.dl_settings.rx1_dr_offset",
	"payload.Payload.join_accept_payload.dl_settings.rx2_dr",
	"payload.Payload.join_accept_payload.encrypted",
	"payload.Payload.join_accept_payload.join_nonce",
	"payload.Payload.join_accept_payload.net_id",
	"payload.Payload.join_accept_payload.rx_delay",
	"payload.Payload.join_request_payload",
	"payload.Payload.join_request_payload.dev_eui",
	"payload.Payload.join_request_payload.dev_nonce",
	"payload.Payload.join_request_payload.join_eui",
	"payload.Payload.mac_payload",
	"payload.Payload.mac_payload.decoded_payload",
	"payload.Payload.mac_payload.f_hdr",
	"payload.Payload.mac_payload.f_hdr.dev_addr",
	"payload.Payload.mac_payload.f_hdr.f_cnt",
	"payload.Payload.mac_payload.f_hdr.f_ctrl",
	"payload.Payload.mac_payload.f_hdr.f_ctrl.ack",
	"payload.Payload.mac_payload.f_hdr.f_ctrl.adr",
	"payload.Payload.mac_payload.f_hdr.f_ctrl.adr_ack_req",
	"payload.Payload.mac_payload.f_hdr.f_ctrl.class_b",
	"payload.Payload.mac_payload.f_hdr.f_ctrl.f_pending",
	"payload.Payload.mac_payload.f_hdr.f_opts",
	"payload.Payload.mac_payload.f_port",
	"payload.Payload.mac_payload.frm_payload",
	"payload.Payload.rejoin_request_payload",
	"payload.Payload.rejoin_request_payload.dev_eui",
	"payload.Payload.rejoin_request_payload.join_eui",
	"payload.Payload.rejoin_request_payload.net_id",
	"payload.Payload.rejoin_request_payload.rejoin_cnt",
	"payload.Payload.rejoin_request_payload.rejoin_type",
	"payload.m_hdr",
	"payload.m_hdr.m_type",
	"payload.m_hdr.major",
	"payload.mic",
	"raw_payload",
	"received_at",
	"rx_metadata",
	"settings",
	"settings.bandwidth",
	"settings.bit_rate",
	"settings.channel_index",
	"settings.coding_rate",
	"settings.data_rate_index",
	"settings.enable_crc",
	"settings.frequency",
	"settings.invert_polarization",
	"settings.modulation",
	"settings.spreading_factor",
	"settings.tx_power",
}

var UplinkMessageFieldPathsTopLevel = []string{
	"Payload",
	"correlation_ids",
	"end_device_ids",
	"payload",
	"raw_payload",
	"received_at",
	"rx_metadata",
	"settings",
}

func (dst *UplinkMessage) SetFields(src *UplinkMessage, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "raw_payload":
			if len(subs) > 0 {
				return fmt.Errorf("'raw_payload' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.RawPayload = src.RawPayload
			} else {
				var zero []byte
				dst.RawPayload = zero
			}
		case "payload":
			if len(subs) > 0 {
				newDst := dst.Payload
				if newDst == nil {
					newDst = &Message{}
					dst.Payload = newDst
				}
				var newSrc *Message
				if src != nil {
					newSrc = src.Payload
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.Payload = src.Payload
				} else {
					dst.Payload = nil
				}
			}
		case "end_device_ids":
			if len(subs) > 0 {
				newDst := dst.EndDeviceIDs
				if newDst == nil {
					newDst = &EndDeviceIdentifiers{}
					dst.EndDeviceIDs = newDst
				}
				var newSrc *EndDeviceIdentifiers
				if src != nil {
					newSrc = src.EndDeviceIDs
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.EndDeviceIDs = src.EndDeviceIDs
				} else {
					dst.EndDeviceIDs = nil
				}
			}
		case "settings":
			if len(subs) > 0 {
				newDst := &dst.Settings
				var newSrc *TxSettings
				if src != nil {
					newSrc = &src.Settings
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.Settings = src.Settings
				} else {
					var zero TxSettings
					dst.Settings = zero
				}
			}
		case "rx_metadata":
			if len(subs) > 0 {
				return fmt.Errorf("'rx_metadata' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.RxMetadata = src.RxMetadata
			} else {
				dst.RxMetadata = nil
			}
		case "received_at":
			if len(subs) > 0 {
				return fmt.Errorf("'received_at' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ReceivedAt = src.ReceivedAt
			} else {
				var zero time.Time
				dst.ReceivedAt = zero
			}
		case "correlation_ids":
			if len(subs) > 0 {
				return fmt.Errorf("'correlation_ids' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.CorrelationIDs = src.CorrelationIDs
			} else {
				dst.CorrelationIDs = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var DownlinkMessageFieldPathsNested = []string{
	"Payload",
	"correlation_ids",
	"end_device_ids",
	"end_device_ids.application_ids",
	"end_device_ids.application_ids.application_id",
	"end_device_ids.dev_addr",
	"end_device_ids.dev_eui",
	"end_device_ids.device_id",
	"end_device_ids.join_eui",
	"payload",
	"payload.Payload.join_accept_payload",
	"payload.Payload.join_accept_payload.cf_list",
	"payload.Payload.join_accept_payload.cf_list.ch_masks",
	"payload.Payload.join_accept_payload.cf_list.freq",
	"payload.Payload.join_accept_payload.cf_list.type",
	"payload.Payload.join_accept_payload.dev_addr",
	"payload.Payload.join_accept_payload.dl_settings",
	"payload.Payload.join_accept_payload.dl_settings.opt_neg",
	"payload.Payload.join_accept_payload.dl_settings.rx1_dr_offset",
	"payload.Payload.join_accept_payload.dl_settings.rx2_dr",
	"payload.Payload.join_accept_payload.encrypted",
	"payload.Payload.join_accept_payload.join_nonce",
	"payload.Payload.join_accept_payload.net_id",
	"payload.Payload.join_accept_payload.rx_delay",
	"payload.Payload.join_request_payload",
	"payload.Payload.join_request_payload.dev_eui",
	"payload.Payload.join_request_payload.dev_nonce",
	"payload.Payload.join_request_payload.join_eui",
	"payload.Payload.mac_payload",
	"payload.Payload.mac_payload.decoded_payload",
	"payload.Payload.mac_payload.f_hdr",
	"payload.Payload.mac_payload.f_hdr.dev_addr",
	"payload.Payload.mac_payload.f_hdr.f_cnt",
	"payload.Payload.mac_payload.f_hdr.f_ctrl",
	"payload.Payload.mac_payload.f_hdr.f_ctrl.ack",
	"payload.Payload.mac_payload.f_hdr.f_ctrl.adr",
	"payload.Payload.mac_payload.f_hdr.f_ctrl.adr_ack_req",
	"payload.Payload.mac_payload.f_hdr.f_ctrl.class_b",
	"payload.Payload.mac_payload.f_hdr.f_ctrl.f_pending",
	"payload.Payload.mac_payload.f_hdr.f_opts",
	"payload.Payload.mac_payload.f_port",
	"payload.Payload.mac_payload.frm_payload",
	"payload.Payload.rejoin_request_payload",
	"payload.Payload.rejoin_request_payload.dev_eui",
	"payload.Payload.rejoin_request_payload.join_eui",
	"payload.Payload.rejoin_request_payload.net_id",
	"payload.Payload.rejoin_request_payload.rejoin_cnt",
	"payload.Payload.rejoin_request_payload.rejoin_type",
	"payload.m_hdr",
	"payload.m_hdr.m_type",
	"payload.m_hdr.major",
	"payload.mic",
	"raw_payload",
	"settings",
	"settings.bandwidth",
	"settings.bit_rate",
	"settings.channel_index",
	"settings.coding_rate",
	"settings.data_rate_index",
	"settings.enable_crc",
	"settings.frequency",
	"settings.invert_polarization",
	"settings.modulation",
	"settings.spreading_factor",
	"settings.tx_power",
	"tx_metadata",
	"tx_metadata.advanced",
	"tx_metadata.antenna_index",
	"tx_metadata.gateway_ids",
	"tx_metadata.gateway_ids.eui",
	"tx_metadata.gateway_ids.gateway_id",
	"tx_metadata.time",
	"tx_metadata.timestamp",
}

var DownlinkMessageFieldPathsTopLevel = []string{
	"Payload",
	"correlation_ids",
	"end_device_ids",
	"payload",
	"raw_payload",
	"settings",
	"tx_metadata",
}

func (dst *DownlinkMessage) SetFields(src *DownlinkMessage, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "raw_payload":
			if len(subs) > 0 {
				return fmt.Errorf("'raw_payload' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.RawPayload = src.RawPayload
			} else {
				var zero []byte
				dst.RawPayload = zero
			}
		case "payload":
			if len(subs) > 0 {
				newDst := dst.Payload
				if newDst == nil {
					newDst = &Message{}
					dst.Payload = newDst
				}
				var newSrc *Message
				if src != nil {
					newSrc = src.Payload
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.Payload = src.Payload
				} else {
					dst.Payload = nil
				}
			}
		case "end_device_ids":
			if len(subs) > 0 {
				newDst := dst.EndDeviceIDs
				if newDst == nil {
					newDst = &EndDeviceIdentifiers{}
					dst.EndDeviceIDs = newDst
				}
				var newSrc *EndDeviceIdentifiers
				if src != nil {
					newSrc = src.EndDeviceIDs
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.EndDeviceIDs = src.EndDeviceIDs
				} else {
					dst.EndDeviceIDs = nil
				}
			}
		case "settings":
			if len(subs) > 0 {
				newDst := &dst.Settings
				var newSrc *TxSettings
				if src != nil {
					newSrc = &src.Settings
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.Settings = src.Settings
				} else {
					var zero TxSettings
					dst.Settings = zero
				}
			}
		case "tx_metadata":
			if len(subs) > 0 {
				newDst := &dst.TxMetadata
				var newSrc *TxMetadata
				if src != nil {
					newSrc = &src.TxMetadata
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.TxMetadata = src.TxMetadata
				} else {
					var zero TxMetadata
					dst.TxMetadata = zero
				}
			}
		case "correlation_ids":
			if len(subs) > 0 {
				return fmt.Errorf("'correlation_ids' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.CorrelationIDs = src.CorrelationIDs
			} else {
				dst.CorrelationIDs = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var TxAcknowledgmentFieldPathsNested = []string{
	"correlation_ids",
	"result",
}

var TxAcknowledgmentFieldPathsTopLevel = []string{
	"correlation_ids",
	"result",
}

func (dst *TxAcknowledgment) SetFields(src *TxAcknowledgment, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "correlation_ids":
			if len(subs) > 0 {
				return fmt.Errorf("'correlation_ids' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.CorrelationIDs = src.CorrelationIDs
			} else {
				dst.CorrelationIDs = nil
			}
		case "result":
			if len(subs) > 0 {
				return fmt.Errorf("'result' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Result = src.Result
			} else {
				var zero TxAcknowledgment_Result
				dst.Result = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var ApplicationUplinkFieldPathsNested = []string{
	"decoded_payload",
	"f_cnt",
	"f_port",
	"frm_payload",
	"rx_metadata",
	"session_key_id",
	"settings",
	"settings.bandwidth",
	"settings.bit_rate",
	"settings.channel_index",
	"settings.coding_rate",
	"settings.data_rate_index",
	"settings.enable_crc",
	"settings.frequency",
	"settings.invert_polarization",
	"settings.modulation",
	"settings.spreading_factor",
	"settings.tx_power",
}

var ApplicationUplinkFieldPathsTopLevel = []string{
	"decoded_payload",
	"f_cnt",
	"f_port",
	"frm_payload",
	"rx_metadata",
	"session_key_id",
	"settings",
}

func (dst *ApplicationUplink) SetFields(src *ApplicationUplink, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "session_key_id":
			if len(subs) > 0 {
				return fmt.Errorf("'session_key_id' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.SessionKeyID = src.SessionKeyID
			} else {
				var zero string
				dst.SessionKeyID = zero
			}
		case "f_port":
			if len(subs) > 0 {
				return fmt.Errorf("'f_port' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.FPort = src.FPort
			} else {
				var zero uint32
				dst.FPort = zero
			}
		case "f_cnt":
			if len(subs) > 0 {
				return fmt.Errorf("'f_cnt' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.FCnt = src.FCnt
			} else {
				var zero uint32
				dst.FCnt = zero
			}
		case "frm_payload":
			if len(subs) > 0 {
				return fmt.Errorf("'frm_payload' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.FRMPayload = src.FRMPayload
			} else {
				var zero []byte
				dst.FRMPayload = zero
			}
		case "decoded_payload":
			if len(subs) > 0 {
				return fmt.Errorf("'decoded_payload' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.DecodedPayload = src.DecodedPayload
			} else {
				dst.DecodedPayload = nil
			}
		case "rx_metadata":
			if len(subs) > 0 {
				return fmt.Errorf("'rx_metadata' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.RxMetadata = src.RxMetadata
			} else {
				dst.RxMetadata = nil
			}
		case "settings":
			if len(subs) > 0 {
				newDst := &dst.Settings
				var newSrc *TxSettings
				if src != nil {
					newSrc = &src.Settings
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.Settings = src.Settings
				} else {
					var zero TxSettings
					dst.Settings = zero
				}
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var ApplicationLocationFieldPathsNested = []string{
	"attributes",
	"location",
	"location.accuracy",
	"location.altitude",
	"location.latitude",
	"location.longitude",
	"location.source",
	"service",
}

var ApplicationLocationFieldPathsTopLevel = []string{
	"attributes",
	"location",
	"service",
}

func (dst *ApplicationLocation) SetFields(src *ApplicationLocation, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "service":
			if len(subs) > 0 {
				return fmt.Errorf("'service' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Service = src.Service
			} else {
				var zero string
				dst.Service = zero
			}
		case "location":
			if len(subs) > 0 {
				newDst := &dst.Location
				var newSrc *Location
				if src != nil {
					newSrc = &src.Location
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.Location = src.Location
				} else {
					var zero Location
					dst.Location = zero
				}
			}
		case "attributes":
			if len(subs) > 0 {
				return fmt.Errorf("'attributes' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Attributes = src.Attributes
			} else {
				dst.Attributes = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var ApplicationJoinAcceptFieldPathsNested = []string{
	"app_s_key",
	"app_s_key.kek_label",
	"app_s_key.key",
	"invalidated_downlinks",
	"pending_session",
	"session_key_id",
	"session_started_at",
}

var ApplicationJoinAcceptFieldPathsTopLevel = []string{
	"app_s_key",
	"invalidated_downlinks",
	"pending_session",
	"session_key_id",
	"session_started_at",
}

func (dst *ApplicationJoinAccept) SetFields(src *ApplicationJoinAccept, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "session_key_id":
			if len(subs) > 0 {
				return fmt.Errorf("'session_key_id' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.SessionKeyID = src.SessionKeyID
			} else {
				var zero string
				dst.SessionKeyID = zero
			}
		case "app_s_key":
			if len(subs) > 0 {
				newDst := dst.AppSKey
				if newDst == nil {
					newDst = &KeyEnvelope{}
					dst.AppSKey = newDst
				}
				var newSrc *KeyEnvelope
				if src != nil {
					newSrc = src.AppSKey
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.AppSKey = src.AppSKey
				} else {
					dst.AppSKey = nil
				}
			}
		case "invalidated_downlinks":
			if len(subs) > 0 {
				return fmt.Errorf("'invalidated_downlinks' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.InvalidatedDownlinks = src.InvalidatedDownlinks
			} else {
				dst.InvalidatedDownlinks = nil
			}
		case "pending_session":
			if len(subs) > 0 {
				return fmt.Errorf("'pending_session' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.PendingSession = src.PendingSession
			} else {
				var zero bool
				dst.PendingSession = zero
			}
		case "session_started_at":
			if len(subs) > 0 {
				return fmt.Errorf("'session_started_at' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.SessionStartedAt = src.SessionStartedAt
			} else {
				var zero time.Time
				dst.SessionStartedAt = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var ApplicationDownlinkFieldPathsNested = []string{
	"class_b_c",
	"class_b_c.gateways",
	"class_b_c.time",
	"confirmed",
	"correlation_ids",
	"decoded_payload",
	"f_cnt",
	"f_port",
	"frm_payload",
	"session_key_id",
}

var ApplicationDownlinkFieldPathsTopLevel = []string{
	"class_b_c",
	"confirmed",
	"correlation_ids",
	"decoded_payload",
	"f_cnt",
	"f_port",
	"frm_payload",
	"session_key_id",
}

func (dst *ApplicationDownlink) SetFields(src *ApplicationDownlink, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "session_key_id":
			if len(subs) > 0 {
				return fmt.Errorf("'session_key_id' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.SessionKeyID = src.SessionKeyID
			} else {
				var zero string
				dst.SessionKeyID = zero
			}
		case "f_port":
			if len(subs) > 0 {
				return fmt.Errorf("'f_port' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.FPort = src.FPort
			} else {
				var zero uint32
				dst.FPort = zero
			}
		case "f_cnt":
			if len(subs) > 0 {
				return fmt.Errorf("'f_cnt' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.FCnt = src.FCnt
			} else {
				var zero uint32
				dst.FCnt = zero
			}
		case "frm_payload":
			if len(subs) > 0 {
				return fmt.Errorf("'frm_payload' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.FRMPayload = src.FRMPayload
			} else {
				var zero []byte
				dst.FRMPayload = zero
			}
		case "decoded_payload":
			if len(subs) > 0 {
				return fmt.Errorf("'decoded_payload' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.DecodedPayload = src.DecodedPayload
			} else {
				dst.DecodedPayload = nil
			}
		case "confirmed":
			if len(subs) > 0 {
				return fmt.Errorf("'confirmed' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Confirmed = src.Confirmed
			} else {
				var zero bool
				dst.Confirmed = zero
			}
		case "class_b_c":
			if len(subs) > 0 {
				newDst := dst.ClassBC
				if newDst == nil {
					newDst = &ApplicationDownlink_ClassBC{}
					dst.ClassBC = newDst
				}
				var newSrc *ApplicationDownlink_ClassBC
				if src != nil {
					newSrc = src.ClassBC
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.ClassBC = src.ClassBC
				} else {
					dst.ClassBC = nil
				}
			}
		case "correlation_ids":
			if len(subs) > 0 {
				return fmt.Errorf("'correlation_ids' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.CorrelationIDs = src.CorrelationIDs
			} else {
				dst.CorrelationIDs = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var ApplicationDownlink_ClassBCFieldPathsNested = []string{
	"gateways",
	"time",
}

var ApplicationDownlink_ClassBCFieldPathsTopLevel = []string{
	"gateways",
	"time",
}

func (dst *ApplicationDownlink_ClassBC) SetFields(src *ApplicationDownlink_ClassBC, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "gateways":
			if len(subs) > 0 {
				return fmt.Errorf("'gateways' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Gateways = src.Gateways
			} else {
				dst.Gateways = nil
			}
		case "time":
			if len(subs) > 0 {
				return fmt.Errorf("'time' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Time = src.Time
			} else {
				dst.Time = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var ApplicationDownlink_ClassBC_GatewayAntennaIdentifiersFieldPathsNested = []string{
	"antenna_index",
	"gateway_ids",
	"gateway_ids.eui",
	"gateway_ids.gateway_id",
}

var ApplicationDownlink_ClassBC_GatewayAntennaIdentifiersFieldPathsTopLevel = []string{
	"antenna_index",
	"gateway_ids",
}

func (dst *ApplicationDownlink_ClassBC_GatewayAntennaIdentifiers) SetFields(src *ApplicationDownlink_ClassBC_GatewayAntennaIdentifiers, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "gateway_ids":
			if len(subs) > 0 {
				newDst := &dst.GatewayIdentifiers
				var newSrc *GatewayIdentifiers
				if src != nil {
					newSrc = &src.GatewayIdentifiers
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.GatewayIdentifiers = src.GatewayIdentifiers
				} else {
					var zero GatewayIdentifiers
					dst.GatewayIdentifiers = zero
				}
			}
		case "antenna_index":
			if len(subs) > 0 {
				return fmt.Errorf("'antenna_index' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.AntennaIndex = src.AntennaIndex
			} else {
				var zero uint32
				dst.AntennaIndex = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var ApplicationDownlinksFieldPathsNested = []string{
	"downlinks",
}

var ApplicationDownlinksFieldPathsTopLevel = []string{
	"downlinks",
}

func (dst *ApplicationDownlinks) SetFields(src *ApplicationDownlinks, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "downlinks":
			if len(subs) > 0 {
				return fmt.Errorf("'downlinks' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Downlinks = src.Downlinks
			} else {
				dst.Downlinks = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var ApplicationDownlinkFailedFieldPathsNested = []string{
	"downlink",
	"downlink.class_b_c",
	"downlink.class_b_c.gateways",
	"downlink.class_b_c.time",
	"downlink.confirmed",
	"downlink.correlation_ids",
	"downlink.decoded_payload",
	"downlink.f_cnt",
	"downlink.f_port",
	"downlink.frm_payload",
	"downlink.session_key_id",
	"error",
	"error.attributes",
	"error.cause",
	"error.cause.attributes",
	"error.cause.correlation_id",
	"error.cause.message_format",
	"error.cause.name",
	"error.cause.namespace",
	"error.correlation_id",
	"error.message_format",
	"error.name",
	"error.namespace",
}

var ApplicationDownlinkFailedFieldPathsTopLevel = []string{
	"downlink",
	"error",
}

func (dst *ApplicationDownlinkFailed) SetFields(src *ApplicationDownlinkFailed, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "downlink":
			if len(subs) > 0 {
				newDst := &dst.ApplicationDownlink
				var newSrc *ApplicationDownlink
				if src != nil {
					newSrc = &src.ApplicationDownlink
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.ApplicationDownlink = src.ApplicationDownlink
				} else {
					var zero ApplicationDownlink
					dst.ApplicationDownlink = zero
				}
			}
		case "error":
			if len(subs) > 0 {
				newDst := &dst.Error
				var newSrc *ErrorDetails
				if src != nil {
					newSrc = &src.Error
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.Error = src.Error
				} else {
					var zero ErrorDetails
					dst.Error = zero
				}
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var ApplicationInvalidatedDownlinksFieldPathsNested = []string{
	"downlinks",
	"last_f_cnt_down",
}

var ApplicationInvalidatedDownlinksFieldPathsTopLevel = []string{
	"downlinks",
	"last_f_cnt_down",
}

func (dst *ApplicationInvalidatedDownlinks) SetFields(src *ApplicationInvalidatedDownlinks, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "downlinks":
			if len(subs) > 0 {
				return fmt.Errorf("'downlinks' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Downlinks = src.Downlinks
			} else {
				dst.Downlinks = nil
			}
		case "last_f_cnt_down":
			if len(subs) > 0 {
				return fmt.Errorf("'last_f_cnt_down' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LastFCntDown = src.LastFCntDown
			} else {
				var zero uint32
				dst.LastFCntDown = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var ApplicationUpFieldPathsNested = []string{
	"correlation_ids",
	"end_device_ids",
	"end_device_ids.application_ids",
	"end_device_ids.application_ids.application_id",
	"end_device_ids.dev_addr",
	"end_device_ids.dev_eui",
	"end_device_ids.device_id",
	"end_device_ids.join_eui",
	"up",
	"up.downlink_ack",
	"up.downlink_ack.class_b_c",
	"up.downlink_ack.class_b_c.gateways",
	"up.downlink_ack.class_b_c.time",
	"up.downlink_ack.confirmed",
	"up.downlink_ack.correlation_ids",
	"up.downlink_ack.decoded_payload",
	"up.downlink_ack.f_cnt",
	"up.downlink_ack.f_port",
	"up.downlink_ack.frm_payload",
	"up.downlink_ack.session_key_id",
	"up.downlink_failed",
	"up.downlink_failed.downlink",
	"up.downlink_failed.downlink.class_b_c",
	"up.downlink_failed.downlink.class_b_c.gateways",
	"up.downlink_failed.downlink.class_b_c.time",
	"up.downlink_failed.downlink.confirmed",
	"up.downlink_failed.downlink.correlation_ids",
	"up.downlink_failed.downlink.decoded_payload",
	"up.downlink_failed.downlink.f_cnt",
	"up.downlink_failed.downlink.f_port",
	"up.downlink_failed.downlink.frm_payload",
	"up.downlink_failed.downlink.session_key_id",
	"up.downlink_failed.error",
	"up.downlink_failed.error.attributes",
	"up.downlink_failed.error.cause",
	"up.downlink_failed.error.cause.attributes",
	"up.downlink_failed.error.cause.correlation_id",
	"up.downlink_failed.error.cause.message_format",
	"up.downlink_failed.error.cause.name",
	"up.downlink_failed.error.cause.namespace",
	"up.downlink_failed.error.correlation_id",
	"up.downlink_failed.error.message_format",
	"up.downlink_failed.error.name",
	"up.downlink_failed.error.namespace",
	"up.downlink_nack",
	"up.downlink_nack.class_b_c",
	"up.downlink_nack.class_b_c.gateways",
	"up.downlink_nack.class_b_c.time",
	"up.downlink_nack.confirmed",
	"up.downlink_nack.correlation_ids",
	"up.downlink_nack.decoded_payload",
	"up.downlink_nack.f_cnt",
	"up.downlink_nack.f_port",
	"up.downlink_nack.frm_payload",
	"up.downlink_nack.session_key_id",
	"up.downlink_queue_invalidated",
	"up.downlink_queue_invalidated.downlinks",
	"up.downlink_queue_invalidated.last_f_cnt_down",
	"up.downlink_queued",
	"up.downlink_queued.class_b_c",
	"up.downlink_queued.class_b_c.gateways",
	"up.downlink_queued.class_b_c.time",
	"up.downlink_queued.confirmed",
	"up.downlink_queued.correlation_ids",
	"up.downlink_queued.decoded_payload",
	"up.downlink_queued.f_cnt",
	"up.downlink_queued.f_port",
	"up.downlink_queued.frm_payload",
	"up.downlink_queued.session_key_id",
	"up.downlink_sent",
	"up.downlink_sent.class_b_c",
	"up.downlink_sent.class_b_c.gateways",
	"up.downlink_sent.class_b_c.time",
	"up.downlink_sent.confirmed",
	"up.downlink_sent.correlation_ids",
	"up.downlink_sent.decoded_payload",
	"up.downlink_sent.f_cnt",
	"up.downlink_sent.f_port",
	"up.downlink_sent.frm_payload",
	"up.downlink_sent.session_key_id",
	"up.join_accept",
	"up.join_accept.app_s_key",
	"up.join_accept.app_s_key.kek_label",
	"up.join_accept.app_s_key.key",
	"up.join_accept.invalidated_downlinks",
	"up.join_accept.pending_session",
	"up.join_accept.session_key_id",
	"up.join_accept.session_started_at",
	"up.location_solved",
	"up.location_solved.attributes",
	"up.location_solved.location",
	"up.location_solved.location.accuracy",
	"up.location_solved.location.altitude",
	"up.location_solved.location.latitude",
	"up.location_solved.location.longitude",
	"up.location_solved.location.source",
	"up.location_solved.service",
	"up.uplink_message",
	"up.uplink_message.decoded_payload",
	"up.uplink_message.f_cnt",
	"up.uplink_message.f_port",
	"up.uplink_message.frm_payload",
	"up.uplink_message.rx_metadata",
	"up.uplink_message.session_key_id",
	"up.uplink_message.settings",
	"up.uplink_message.settings.bandwidth",
	"up.uplink_message.settings.bit_rate",
	"up.uplink_message.settings.channel_index",
	"up.uplink_message.settings.coding_rate",
	"up.uplink_message.settings.data_rate_index",
	"up.uplink_message.settings.enable_crc",
	"up.uplink_message.settings.frequency",
	"up.uplink_message.settings.invert_polarization",
	"up.uplink_message.settings.modulation",
	"up.uplink_message.settings.spreading_factor",
	"up.uplink_message.settings.tx_power",
}

var ApplicationUpFieldPathsTopLevel = []string{
	"correlation_ids",
	"end_device_ids",
	"up",
}

func (dst *ApplicationUp) SetFields(src *ApplicationUp, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "end_device_ids":
			if len(subs) > 0 {
				newDst := &dst.EndDeviceIdentifiers
				var newSrc *EndDeviceIdentifiers
				if src != nil {
					newSrc = &src.EndDeviceIdentifiers
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.EndDeviceIdentifiers = src.EndDeviceIdentifiers
				} else {
					var zero EndDeviceIdentifiers
					dst.EndDeviceIdentifiers = zero
				}
			}
		case "correlation_ids":
			if len(subs) > 0 {
				return fmt.Errorf("'correlation_ids' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.CorrelationIDs = src.CorrelationIDs
			} else {
				dst.CorrelationIDs = nil
			}

		case "up":
			if len(subs) == 0 && src == nil {
				dst.Up = nil
				continue
			} else if len(subs) == 0 {
				dst.Up = src.Up
				continue
			}

			subPathMap := _processPaths(subs)
			if len(subPathMap) > 1 {
				return fmt.Errorf("more than one field specified for oneof field '%s'", name)
			}
			for oneofName, oneofSubs := range subPathMap {
				switch oneofName {
				case "uplink_message":
					if _, ok := dst.Up.(*ApplicationUp_UplinkMessage); !ok {
						dst.Up = &ApplicationUp_UplinkMessage{}
					}
					if len(oneofSubs) > 0 {
						newDst := dst.Up.(*ApplicationUp_UplinkMessage).UplinkMessage
						if newDst == nil {
							newDst = &ApplicationUplink{}
							dst.Up.(*ApplicationUp_UplinkMessage).UplinkMessage = newDst
						}
						var newSrc *ApplicationUplink
						if src != nil {
							newSrc = src.GetUplinkMessage()
						}
						if err := newDst.SetFields(newSrc, subs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.Up.(*ApplicationUp_UplinkMessage).UplinkMessage = src.GetUplinkMessage()
						} else {
							dst.Up.(*ApplicationUp_UplinkMessage).UplinkMessage = nil
						}
					}
				case "join_accept":
					if _, ok := dst.Up.(*ApplicationUp_JoinAccept); !ok {
						dst.Up = &ApplicationUp_JoinAccept{}
					}
					if len(oneofSubs) > 0 {
						newDst := dst.Up.(*ApplicationUp_JoinAccept).JoinAccept
						if newDst == nil {
							newDst = &ApplicationJoinAccept{}
							dst.Up.(*ApplicationUp_JoinAccept).JoinAccept = newDst
						}
						var newSrc *ApplicationJoinAccept
						if src != nil {
							newSrc = src.GetJoinAccept()
						}
						if err := newDst.SetFields(newSrc, subs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.Up.(*ApplicationUp_JoinAccept).JoinAccept = src.GetJoinAccept()
						} else {
							dst.Up.(*ApplicationUp_JoinAccept).JoinAccept = nil
						}
					}
				case "downlink_ack":
					if _, ok := dst.Up.(*ApplicationUp_DownlinkAck); !ok {
						dst.Up = &ApplicationUp_DownlinkAck{}
					}
					if len(oneofSubs) > 0 {
						newDst := dst.Up.(*ApplicationUp_DownlinkAck).DownlinkAck
						if newDst == nil {
							newDst = &ApplicationDownlink{}
							dst.Up.(*ApplicationUp_DownlinkAck).DownlinkAck = newDst
						}
						var newSrc *ApplicationDownlink
						if src != nil {
							newSrc = src.GetDownlinkAck()
						}
						if err := newDst.SetFields(newSrc, subs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.Up.(*ApplicationUp_DownlinkAck).DownlinkAck = src.GetDownlinkAck()
						} else {
							dst.Up.(*ApplicationUp_DownlinkAck).DownlinkAck = nil
						}
					}
				case "downlink_nack":
					if _, ok := dst.Up.(*ApplicationUp_DownlinkNack); !ok {
						dst.Up = &ApplicationUp_DownlinkNack{}
					}
					if len(oneofSubs) > 0 {
						newDst := dst.Up.(*ApplicationUp_DownlinkNack).DownlinkNack
						if newDst == nil {
							newDst = &ApplicationDownlink{}
							dst.Up.(*ApplicationUp_DownlinkNack).DownlinkNack = newDst
						}
						var newSrc *ApplicationDownlink
						if src != nil {
							newSrc = src.GetDownlinkNack()
						}
						if err := newDst.SetFields(newSrc, subs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.Up.(*ApplicationUp_DownlinkNack).DownlinkNack = src.GetDownlinkNack()
						} else {
							dst.Up.(*ApplicationUp_DownlinkNack).DownlinkNack = nil
						}
					}
				case "downlink_sent":
					if _, ok := dst.Up.(*ApplicationUp_DownlinkSent); !ok {
						dst.Up = &ApplicationUp_DownlinkSent{}
					}
					if len(oneofSubs) > 0 {
						newDst := dst.Up.(*ApplicationUp_DownlinkSent).DownlinkSent
						if newDst == nil {
							newDst = &ApplicationDownlink{}
							dst.Up.(*ApplicationUp_DownlinkSent).DownlinkSent = newDst
						}
						var newSrc *ApplicationDownlink
						if src != nil {
							newSrc = src.GetDownlinkSent()
						}
						if err := newDst.SetFields(newSrc, subs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.Up.(*ApplicationUp_DownlinkSent).DownlinkSent = src.GetDownlinkSent()
						} else {
							dst.Up.(*ApplicationUp_DownlinkSent).DownlinkSent = nil
						}
					}
				case "downlink_failed":
					if _, ok := dst.Up.(*ApplicationUp_DownlinkFailed); !ok {
						dst.Up = &ApplicationUp_DownlinkFailed{}
					}
					if len(oneofSubs) > 0 {
						newDst := dst.Up.(*ApplicationUp_DownlinkFailed).DownlinkFailed
						if newDst == nil {
							newDst = &ApplicationDownlinkFailed{}
							dst.Up.(*ApplicationUp_DownlinkFailed).DownlinkFailed = newDst
						}
						var newSrc *ApplicationDownlinkFailed
						if src != nil {
							newSrc = src.GetDownlinkFailed()
						}
						if err := newDst.SetFields(newSrc, subs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.Up.(*ApplicationUp_DownlinkFailed).DownlinkFailed = src.GetDownlinkFailed()
						} else {
							dst.Up.(*ApplicationUp_DownlinkFailed).DownlinkFailed = nil
						}
					}
				case "downlink_queued":
					if _, ok := dst.Up.(*ApplicationUp_DownlinkQueued); !ok {
						dst.Up = &ApplicationUp_DownlinkQueued{}
					}
					if len(oneofSubs) > 0 {
						newDst := dst.Up.(*ApplicationUp_DownlinkQueued).DownlinkQueued
						if newDst == nil {
							newDst = &ApplicationDownlink{}
							dst.Up.(*ApplicationUp_DownlinkQueued).DownlinkQueued = newDst
						}
						var newSrc *ApplicationDownlink
						if src != nil {
							newSrc = src.GetDownlinkQueued()
						}
						if err := newDst.SetFields(newSrc, subs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.Up.(*ApplicationUp_DownlinkQueued).DownlinkQueued = src.GetDownlinkQueued()
						} else {
							dst.Up.(*ApplicationUp_DownlinkQueued).DownlinkQueued = nil
						}
					}
				case "downlink_queue_invalidated":
					if _, ok := dst.Up.(*ApplicationUp_DownlinkQueueInvalidated); !ok {
						dst.Up = &ApplicationUp_DownlinkQueueInvalidated{}
					}
					if len(oneofSubs) > 0 {
						newDst := dst.Up.(*ApplicationUp_DownlinkQueueInvalidated).DownlinkQueueInvalidated
						if newDst == nil {
							newDst = &ApplicationInvalidatedDownlinks{}
							dst.Up.(*ApplicationUp_DownlinkQueueInvalidated).DownlinkQueueInvalidated = newDst
						}
						var newSrc *ApplicationInvalidatedDownlinks
						if src != nil {
							newSrc = src.GetDownlinkQueueInvalidated()
						}
						if err := newDst.SetFields(newSrc, subs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.Up.(*ApplicationUp_DownlinkQueueInvalidated).DownlinkQueueInvalidated = src.GetDownlinkQueueInvalidated()
						} else {
							dst.Up.(*ApplicationUp_DownlinkQueueInvalidated).DownlinkQueueInvalidated = nil
						}
					}
				case "location_solved":
					if _, ok := dst.Up.(*ApplicationUp_LocationSolved); !ok {
						dst.Up = &ApplicationUp_LocationSolved{}
					}
					if len(oneofSubs) > 0 {
						newDst := dst.Up.(*ApplicationUp_LocationSolved).LocationSolved
						if newDst == nil {
							newDst = &ApplicationLocation{}
							dst.Up.(*ApplicationUp_LocationSolved).LocationSolved = newDst
						}
						var newSrc *ApplicationLocation
						if src != nil {
							newSrc = src.GetLocationSolved()
						}
						if err := newDst.SetFields(newSrc, subs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.Up.(*ApplicationUp_LocationSolved).LocationSolved = src.GetLocationSolved()
						} else {
							dst.Up.(*ApplicationUp_LocationSolved).LocationSolved = nil
						}
					}

				default:
					return fmt.Errorf("invalid oneof field: '%s.%s'", name, oneofName)
				}
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var MessagePayloadFormattersFieldPathsNested = []string{
	"down_formatter",
	"down_formatter_parameter",
	"up_formatter",
	"up_formatter_parameter",
}

var MessagePayloadFormattersFieldPathsTopLevel = []string{
	"down_formatter",
	"down_formatter_parameter",
	"up_formatter",
	"up_formatter_parameter",
}

func (dst *MessagePayloadFormatters) SetFields(src *MessagePayloadFormatters, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "up_formatter":
			if len(subs) > 0 {
				return fmt.Errorf("'up_formatter' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.UpFormatter = src.UpFormatter
			} else {
				var zero PayloadFormatter
				dst.UpFormatter = zero
			}
		case "up_formatter_parameter":
			if len(subs) > 0 {
				return fmt.Errorf("'up_formatter_parameter' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.UpFormatterParameter = src.UpFormatterParameter
			} else {
				var zero string
				dst.UpFormatterParameter = zero
			}
		case "down_formatter":
			if len(subs) > 0 {
				return fmt.Errorf("'down_formatter' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.DownFormatter = src.DownFormatter
			} else {
				var zero PayloadFormatter
				dst.DownFormatter = zero
			}
		case "down_formatter_parameter":
			if len(subs) > 0 {
				return fmt.Errorf("'down_formatter_parameter' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.DownFormatterParameter = src.DownFormatterParameter
			} else {
				var zero string
				dst.DownFormatterParameter = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var DownlinkQueueRequestFieldPathsNested = []string{
	"downlinks",
	"end_device_ids",
	"end_device_ids.application_ids",
	"end_device_ids.application_ids.application_id",
	"end_device_ids.dev_addr",
	"end_device_ids.dev_eui",
	"end_device_ids.device_id",
	"end_device_ids.join_eui",
}

var DownlinkQueueRequestFieldPathsTopLevel = []string{
	"downlinks",
	"end_device_ids",
}

func (dst *DownlinkQueueRequest) SetFields(src *DownlinkQueueRequest, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "end_device_ids":
			if len(subs) > 0 {
				newDst := &dst.EndDeviceIdentifiers
				var newSrc *EndDeviceIdentifiers
				if src != nil {
					newSrc = &src.EndDeviceIdentifiers
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.EndDeviceIdentifiers = src.EndDeviceIdentifiers
				} else {
					var zero EndDeviceIdentifiers
					dst.EndDeviceIdentifiers = zero
				}
			}
		case "downlinks":
			if len(subs) > 0 {
				return fmt.Errorf("'downlinks' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Downlinks = src.Downlinks
			} else {
				dst.Downlinks = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}
