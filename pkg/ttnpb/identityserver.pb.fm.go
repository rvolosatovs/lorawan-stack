// Code generated by protoc-gen-fieldmask. DO NOT EDIT.

package ttnpb

import fmt "fmt"

var AuthInfoResponseFieldPathsNested = []string{
	"access_method",
	"access_method.api_key",
	"access_method.api_key.api_key",
	"access_method.api_key.api_key.id",
	"access_method.api_key.api_key.key",
	"access_method.api_key.api_key.name",
	"access_method.api_key.api_key.rights",
	"access_method.api_key.entity_ids",
	"access_method.api_key.entity_ids.ids",
	"access_method.api_key.entity_ids.ids.application_ids",
	"access_method.api_key.entity_ids.ids.application_ids.application_id",
	"access_method.api_key.entity_ids.ids.client_ids",
	"access_method.api_key.entity_ids.ids.client_ids.client_id",
	"access_method.api_key.entity_ids.ids.device_ids",
	"access_method.api_key.entity_ids.ids.device_ids.application_ids",
	"access_method.api_key.entity_ids.ids.device_ids.application_ids.application_id",
	"access_method.api_key.entity_ids.ids.device_ids.dev_addr",
	"access_method.api_key.entity_ids.ids.device_ids.dev_eui",
	"access_method.api_key.entity_ids.ids.device_ids.device_id",
	"access_method.api_key.entity_ids.ids.device_ids.join_eui",
	"access_method.api_key.entity_ids.ids.gateway_ids",
	"access_method.api_key.entity_ids.ids.gateway_ids.eui",
	"access_method.api_key.entity_ids.ids.gateway_ids.gateway_id",
	"access_method.api_key.entity_ids.ids.organization_ids",
	"access_method.api_key.entity_ids.ids.organization_ids.organization_id",
	"access_method.api_key.entity_ids.ids.user_ids",
	"access_method.api_key.entity_ids.ids.user_ids.email",
	"access_method.api_key.entity_ids.ids.user_ids.user_id",
	"access_method.oauth_access_token",
	"access_method.oauth_access_token.access_token",
	"access_method.oauth_access_token.client_ids",
	"access_method.oauth_access_token.client_ids.client_id",
	"access_method.oauth_access_token.created_at",
	"access_method.oauth_access_token.expires_at",
	"access_method.oauth_access_token.id",
	"access_method.oauth_access_token.refresh_token",
	"access_method.oauth_access_token.rights",
	"access_method.oauth_access_token.user_ids",
	"access_method.oauth_access_token.user_ids.email",
	"access_method.oauth_access_token.user_ids.user_id",
	"universal_rights",
	"universal_rights.rights",
}

var AuthInfoResponseFieldPathsTopLevel = []string{
	"access_method",
	"universal_rights",
}

func (dst *AuthInfoResponse) SetFields(src *AuthInfoResponse, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "universal_rights":
			if len(subs) > 0 {
				newDst := dst.UniversalRights
				if newDst == nil {
					newDst = &Rights{}
					dst.UniversalRights = newDst
				}
				var newSrc *Rights
				if src != nil {
					newSrc = src.UniversalRights
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.UniversalRights = src.UniversalRights
				} else {
					dst.UniversalRights = nil
				}
			}

		case "access_method":
			if len(subs) == 0 && src == nil {
				dst.AccessMethod = nil
				continue
			} else if len(subs) == 0 {
				dst.AccessMethod = src.AccessMethod
				continue
			}

			subPathMap := _processPaths(subs)
			if len(subPathMap) > 1 {
				return fmt.Errorf("more than one field specified for oneof field '%s'", name)
			}
			for oneofName, oneofSubs := range subPathMap {
				switch oneofName {
				case "api_key":
					if _, ok := dst.AccessMethod.(*AuthInfoResponse_APIKey); !ok {
						dst.AccessMethod = &AuthInfoResponse_APIKey{}
					}
					if len(oneofSubs) > 0 {
						newDst := dst.AccessMethod.(*AuthInfoResponse_APIKey).APIKey
						if newDst == nil {
							newDst = &AuthInfoResponse_APIKeyAccess{}
							dst.AccessMethod.(*AuthInfoResponse_APIKey).APIKey = newDst
						}
						var newSrc *AuthInfoResponse_APIKeyAccess
						if src != nil {
							newSrc = src.GetAPIKey()
						}
						if err := newDst.SetFields(newSrc, subs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.AccessMethod.(*AuthInfoResponse_APIKey).APIKey = src.GetAPIKey()
						} else {
							dst.AccessMethod.(*AuthInfoResponse_APIKey).APIKey = nil
						}
					}
				case "oauth_access_token":
					if _, ok := dst.AccessMethod.(*AuthInfoResponse_OAuthAccessToken); !ok {
						dst.AccessMethod = &AuthInfoResponse_OAuthAccessToken{}
					}
					if len(oneofSubs) > 0 {
						newDst := dst.AccessMethod.(*AuthInfoResponse_OAuthAccessToken).OAuthAccessToken
						if newDst == nil {
							newDst = &OAuthAccessToken{}
							dst.AccessMethod.(*AuthInfoResponse_OAuthAccessToken).OAuthAccessToken = newDst
						}
						var newSrc *OAuthAccessToken
						if src != nil {
							newSrc = src.GetOAuthAccessToken()
						}
						if err := newDst.SetFields(newSrc, subs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.AccessMethod.(*AuthInfoResponse_OAuthAccessToken).OAuthAccessToken = src.GetOAuthAccessToken()
						} else {
							dst.AccessMethod.(*AuthInfoResponse_OAuthAccessToken).OAuthAccessToken = nil
						}
					}

				default:
					return fmt.Errorf("invalid oneof field: '%s.%s'", name, oneofName)
				}
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

var AuthInfoResponse_APIKeyAccessFieldPathsNested = []string{
	"api_key",
	"api_key.id",
	"api_key.key",
	"api_key.name",
	"api_key.rights",
	"entity_ids",
	"entity_ids.ids",
	"entity_ids.ids.application_ids",
	"entity_ids.ids.application_ids.application_id",
	"entity_ids.ids.client_ids",
	"entity_ids.ids.client_ids.client_id",
	"entity_ids.ids.device_ids",
	"entity_ids.ids.device_ids.application_ids",
	"entity_ids.ids.device_ids.application_ids.application_id",
	"entity_ids.ids.device_ids.dev_addr",
	"entity_ids.ids.device_ids.dev_eui",
	"entity_ids.ids.device_ids.device_id",
	"entity_ids.ids.device_ids.join_eui",
	"entity_ids.ids.gateway_ids",
	"entity_ids.ids.gateway_ids.eui",
	"entity_ids.ids.gateway_ids.gateway_id",
	"entity_ids.ids.organization_ids",
	"entity_ids.ids.organization_ids.organization_id",
	"entity_ids.ids.user_ids",
	"entity_ids.ids.user_ids.email",
	"entity_ids.ids.user_ids.user_id",
}

var AuthInfoResponse_APIKeyAccessFieldPathsTopLevel = []string{
	"api_key",
	"entity_ids",
}

func (dst *AuthInfoResponse_APIKeyAccess) SetFields(src *AuthInfoResponse_APIKeyAccess, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "api_key":
			if len(subs) > 0 {
				newDst := &dst.APIKey
				var newSrc *APIKey
				if src != nil {
					newSrc = &src.APIKey
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.APIKey = src.APIKey
				} else {
					var zero APIKey
					dst.APIKey = zero
				}
			}
		case "entity_ids":
			if len(subs) > 0 {
				newDst := &dst.EntityIDs
				var newSrc *EntityIdentifiers
				if src != nil {
					newSrc = &src.EntityIDs
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.EntityIDs = src.EntityIDs
				} else {
					var zero EntityIdentifiers
					dst.EntityIDs = zero
				}
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}
