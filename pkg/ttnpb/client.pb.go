// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/TheThingsNetwork/ttn/api/client.proto

package ttnpb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/gogo/protobuf/types"

import time "time"

import strconv "strconv"

import github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// ClientState enum defines all the possible staff reviewing states that a
// third-party client request can be at.
type ClientState int32

const (
	// State that denotes that the client request is pending to review by the staff.
	StatePending ClientState = 0
	// Denotes that the client request has been approved by the staff and therefore
	// the client can be used.
	StateApproved ClientState = 1
	// Denotes that the client request has beenr rejected by the staff and therefore
	// it cannot be used.
	StateRejected ClientState = 2
)

var ClientState_name = map[int32]string{
	0: "PENDING",
	1: "APPROVED",
	2: "REJECTED",
}
var ClientState_value = map[string]int32{
	"PENDING":  0,
	"APPROVED": 1,
	"REJECTED": 2,
}

func (ClientState) EnumDescriptor() ([]byte, []int) { return fileDescriptorClient, []int{0} }

// Scope enum defines the different scopes a third-party client can have access to.
type Scope int32

const (
	ScopeApplication Scope = 0
	ScopeProfile     Scope = 1
)

var Scope_name = map[int32]string{
	0: "APPLICATION",
	1: "PROFILE",
}
var Scope_value = map[string]int32{
	"APPLICATION": 0,
	"PROFILE":     1,
}

func (Scope) EnumDescriptor() ([]byte, []int) { return fileDescriptorClient, []int{1} }

// Grant enum defines the OAuth2 flows a third-party client can use to get access
// to a token.
type Grant int32

const (
	GrantAuthorizationCode Grant = 0
	GrantPassword          Grant = 1
	GrantRefreshToken      Grant = 2
)

var Grant_name = map[int32]string{
	0: "AUTHORIZATION_CODE",
	1: "PASSWORD",
	2: "REFRESH_TOKEN",
}
var Grant_value = map[string]int32{
	"AUTHORIZATION_CODE": 0,
	"PASSWORD":           1,
	"REFRESH_TOKEN":      2,
}

func (Grant) EnumDescriptor() ([]byte, []int) { return fileDescriptorClient, []int{2} }

// Client is the message that defines a third-party client on the network.
type Client struct {
	// client_id is the unique client identifier.
	ID string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// description is the description of the client.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// secret is the secret used to prove the client identity.
	Secret string `protobuf:"bytes,3,opt,name=secret,proto3" json:"secret,omitempty"`
	// callback_uri is the callback URI of the client.
	CallbackURI string `protobuf:"bytes,4,opt,name=callback_uri,json=callbackUri,proto3" json:"callback_uri,omitempty" db:"callback_uri"`
	// state denotes the reviewing state of the client by the staff.
	// It can be either: pending, accepted or rejected.
	State ClientState `protobuf:"varint,5,opt,name=state,proto3,enum=ttn.v3.ClientState" json:"state,omitempty"`
	// official denotes if the client is an official client created by the staff.
	Official bool `protobuf:"varint,6,opt,name=official,proto3" json:"official,omitempty"`
	// grants denotes which OAuth2 flows can the client use to get a token.
	Grants ClientGrants `protobuf:"bytes,7,opt,name=grants" json:"grants"`
	// scope denotes what scopes the client will have access to.
	Scope ClientScope `protobuf:"bytes,8,opt,name=scope" json:"scope"`
	// created denotes when the client was created.
	Created time.Time `protobuf:"bytes,9,opt,name=created,stdtime" json:"created"`
	// archived denotes when the client was disabled.
	Archived *time.Time `protobuf:"bytes,10,opt,name=archived,stdtime" json:"archived,omitempty"`
}

func (m *Client) Reset()                    { *m = Client{} }
func (*Client) ProtoMessage()               {}
func (*Client) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{0} }

func (m *Client) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Client) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Client) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

func (m *Client) GetCallbackURI() string {
	if m != nil {
		return m.CallbackURI
	}
	return ""
}

func (m *Client) GetState() ClientState {
	if m != nil {
		return m.State
	}
	return StatePending
}

func (m *Client) GetOfficial() bool {
	if m != nil {
		return m.Official
	}
	return false
}

func (m *Client) GetGrants() ClientGrants {
	if m != nil {
		return m.Grants
	}
	return ClientGrants{}
}

func (m *Client) GetScope() ClientScope {
	if m != nil {
		return m.Scope
	}
	return ClientScope{}
}

func (m *Client) GetCreated() time.Time {
	if m != nil {
		return m.Created
	}
	return time.Time{}
}

func (m *Client) GetArchived() *time.Time {
	if m != nil {
		return m.Archived
	}
	return nil
}

// ClientScope is the message that defines the scope of a third-party client.
type ClientScope struct {
	// application denotes whether if the client has access to manage user's applications.
	Application bool `protobuf:"varint,1,opt,name=application,proto3" json:"application,omitempty"`
	// profile denotes wheter if the client has r-w access to user's profile.
	Profile bool `protobuf:"varint,2,opt,name=profile,proto3" json:"profile,omitempty"`
}

func (m *ClientScope) Reset()                    { *m = ClientScope{} }
func (*ClientScope) ProtoMessage()               {}
func (*ClientScope) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{1} }

func (m *ClientScope) GetApplication() bool {
	if m != nil {
		return m.Application
	}
	return false
}

func (m *ClientScope) GetProfile() bool {
	if m != nil {
		return m.Profile
	}
	return false
}

// ClientGrants is the message that defines which grants a third-party client can
// use to get access tokens.
type ClientGrants struct {
	// authorization_code is the grant type used to exchange an authorization
	// code for an access token.
	AuthorizationCode bool `protobuf:"varint,1,opt,name=authorization_code,json=authorizationCode,proto3" json:"authorization_code,omitempty"`
	// password is the grant type used to exchange an username and password
	// for an access token.
	Password bool `protobuf:"varint,2,opt,name=password,proto3" json:"password,omitempty"`
	// refresh_token is the grant type used to exchange a refresh token for
	// an access token.
	RefreshToken bool `protobuf:"varint,3,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
}

func (m *ClientGrants) Reset()                    { *m = ClientGrants{} }
func (*ClientGrants) ProtoMessage()               {}
func (*ClientGrants) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{2} }

func (m *ClientGrants) GetAuthorizationCode() bool {
	if m != nil {
		return m.AuthorizationCode
	}
	return false
}

func (m *ClientGrants) GetPassword() bool {
	if m != nil {
		return m.Password
	}
	return false
}

func (m *ClientGrants) GetRefreshToken() bool {
	if m != nil {
		return m.RefreshToken
	}
	return false
}

func init() {
	proto.RegisterType((*Client)(nil), "ttn.v3.Client")
	proto.RegisterType((*ClientScope)(nil), "ttn.v3.ClientScope")
	proto.RegisterType((*ClientGrants)(nil), "ttn.v3.ClientGrants")
	proto.RegisterEnum("ttn.v3.ClientState", ClientState_name, ClientState_value)
	proto.RegisterEnum("ttn.v3.Scope", Scope_name, Scope_value)
	proto.RegisterEnum("ttn.v3.Grant", Grant_name, Grant_value)
}
func (x ClientState) String() string {
	s, ok := ClientState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Scope) String() string {
	s, ok := Scope_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Grant) String() string {
	s, ok := Grant_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (m *Client) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Client) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClient(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintClient(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Secret) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintClient(dAtA, i, uint64(len(m.Secret)))
		i += copy(dAtA[i:], m.Secret)
	}
	if len(m.CallbackURI) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintClient(dAtA, i, uint64(len(m.CallbackURI)))
		i += copy(dAtA[i:], m.CallbackURI)
	}
	if m.State != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintClient(dAtA, i, uint64(m.State))
	}
	if m.Official {
		dAtA[i] = 0x30
		i++
		if m.Official {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintClient(dAtA, i, uint64(m.Grants.Size()))
	n1, err := m.Grants.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x42
	i++
	i = encodeVarintClient(dAtA, i, uint64(m.Scope.Size()))
	n2, err := m.Scope.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x4a
	i++
	i = encodeVarintClient(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.Created)))
	n3, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Created, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.Archived != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintClient(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.Archived)))
		n4, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Archived, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *ClientScope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientScope) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Application {
		dAtA[i] = 0x8
		i++
		if m.Application {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Profile {
		dAtA[i] = 0x10
		i++
		if m.Profile {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ClientGrants) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientGrants) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthorizationCode {
		dAtA[i] = 0x8
		i++
		if m.AuthorizationCode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Password {
		dAtA[i] = 0x10
		i++
		if m.Password {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RefreshToken {
		dAtA[i] = 0x18
		i++
		if m.RefreshToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeFixed64Client(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Client(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintClient(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Client) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	l = len(m.CallbackURI)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovClient(uint64(m.State))
	}
	if m.Official {
		n += 2
	}
	l = m.Grants.Size()
	n += 1 + l + sovClient(uint64(l))
	l = m.Scope.Size()
	n += 1 + l + sovClient(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Created)
	n += 1 + l + sovClient(uint64(l))
	if m.Archived != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Archived)
		n += 1 + l + sovClient(uint64(l))
	}
	return n
}

func (m *ClientScope) Size() (n int) {
	var l int
	_ = l
	if m.Application {
		n += 2
	}
	if m.Profile {
		n += 2
	}
	return n
}

func (m *ClientGrants) Size() (n int) {
	var l int
	_ = l
	if m.AuthorizationCode {
		n += 2
	}
	if m.Password {
		n += 2
	}
	if m.RefreshToken {
		n += 2
	}
	return n
}

func sovClient(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozClient(x uint64) (n int) {
	return sovClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Client) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Client{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Secret:` + fmt.Sprintf("%v", this.Secret) + `,`,
		`CallbackURI:` + fmt.Sprintf("%v", this.CallbackURI) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Official:` + fmt.Sprintf("%v", this.Official) + `,`,
		`Grants:` + strings.Replace(strings.Replace(this.Grants.String(), "ClientGrants", "ClientGrants", 1), `&`, ``, 1) + `,`,
		`Scope:` + strings.Replace(strings.Replace(this.Scope.String(), "ClientScope", "ClientScope", 1), `&`, ``, 1) + `,`,
		`Created:` + strings.Replace(strings.Replace(this.Created.String(), "Timestamp", "google_protobuf1.Timestamp", 1), `&`, ``, 1) + `,`,
		`Archived:` + strings.Replace(fmt.Sprintf("%v", this.Archived), "Timestamp", "google_protobuf1.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientScope) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientScope{`,
		`Application:` + fmt.Sprintf("%v", this.Application) + `,`,
		`Profile:` + fmt.Sprintf("%v", this.Profile) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientGrants) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientGrants{`,
		`AuthorizationCode:` + fmt.Sprintf("%v", this.AuthorizationCode) + `,`,
		`Password:` + fmt.Sprintf("%v", this.Password) + `,`,
		`RefreshToken:` + fmt.Sprintf("%v", this.RefreshToken) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringClient(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Client) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Client: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Client: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallbackURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallbackURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (ClientState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Official", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Official = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Grants.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Scope.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archived", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Archived == nil {
				m.Archived = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Archived, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientScope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientScope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientScope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Application", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Application = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Profile = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientGrants) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientGrants: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientGrants: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizationCode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AuthorizationCode = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Password = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RefreshToken = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthClient
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowClient
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipClient(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthClient = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClient   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/TheThingsNetwork/ttn/api/client.proto", fileDescriptorClient)
}

var fileDescriptorClient = []byte{
	// 751 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0x41, 0x8f, 0xdb, 0x44,
	0x18, 0x8d, 0xb7, 0x9b, 0xc4, 0x3b, 0xc9, 0x22, 0x67, 0x28, 0x95, 0x65, 0x09, 0xdb, 0x4a, 0x41,
	0x4a, 0x2b, 0xd5, 0x41, 0xe9, 0x0d, 0x21, 0x24, 0x27, 0x71, 0x53, 0x43, 0x95, 0x58, 0x13, 0x2f,
	0x48, 0xbd, 0x44, 0x8e, 0x3d, 0x71, 0x86, 0x64, 0x3d, 0x96, 0x3d, 0xd9, 0x4a, 0x1c, 0x10, 0x47,
	0x14, 0x71, 0xe0, 0x0f, 0xe4, 0xc4, 0x9f, 0xe9, 0x91, 0x23, 0xe2, 0x10, 0xc0, 0x27, 0x8e, 0x88,
	0x5f, 0x80, 0x3c, 0x76, 0x82, 0x4b, 0x0f, 0x3d, 0x25, 0xdf, 0xf7, 0xde, 0xfb, 0xe6, 0x9b, 0xf7,
	0x46, 0x06, 0x9f, 0x84, 0x84, 0xad, 0x77, 0x4b, 0xc3, 0xa7, 0xb7, 0x7d, 0x77, 0x8d, 0xdd, 0x35,
	0x89, 0xc2, 0x74, 0x8a, 0xd9, 0x2b, 0x9a, 0x6c, 0xfa, 0x8c, 0x45, 0x7d, 0x2f, 0x26, 0x7d, 0x7f,
	0x4b, 0x70, 0xc4, 0x8c, 0x38, 0xa1, 0x8c, 0xc2, 0x06, 0x63, 0x91, 0x71, 0xf7, 0x54, 0x79, 0x52,
	0x51, 0x86, 0x34, 0xa4, 0x7d, 0x0e, 0x2f, 0x77, 0x2b, 0x5e, 0xf1, 0x82, 0xff, 0x2b, 0x64, 0x8a,
	0x16, 0x52, 0x1a, 0x6e, 0xf1, 0x7f, 0x2c, 0x46, 0x6e, 0x71, 0xca, 0xbc, 0xdb, 0xb8, 0x20, 0x74,
	0x7f, 0xbb, 0x07, 0x1a, 0x23, 0x7e, 0x10, 0x7c, 0x08, 0xae, 0x8a, 0x23, 0x17, 0x24, 0x90, 0x05,
	0x5d, 0xe8, 0x5d, 0x0d, 0x1b, 0xd9, 0x51, 0xbb, 0xb0, 0xc7, 0x48, 0x2c, 0x00, 0x3b, 0x80, 0x3a,
	0x68, 0x05, 0x38, 0xf5, 0x13, 0x12, 0x33, 0x42, 0x23, 0xf9, 0x22, 0xa7, 0xa1, 0x6a, 0x0b, 0x3e,
	0x00, 0x8d, 0x14, 0xfb, 0x09, 0x66, 0xf2, 0x3d, 0x0e, 0x96, 0x15, 0x9c, 0x80, 0xb6, 0xef, 0x6d,
	0xb7, 0x4b, 0xcf, 0xdf, 0x2c, 0x76, 0x09, 0x91, 0x2f, 0xf9, 0x09, 0x1f, 0x65, 0x47, 0xad, 0x35,
	0x2a, 0xfb, 0x37, 0xc8, 0xfe, 0xe7, 0xa8, 0x75, 0x82, 0xe5, 0xa7, 0xdd, 0x2a, 0xb5, 0x8b, 0x5a,
	0xa7, 0xf2, 0x26, 0x21, 0xf0, 0x11, 0xa8, 0xa7, 0xcc, 0x63, 0x58, 0xae, 0xeb, 0x42, 0xef, 0xbd,
	0xc1, 0xfb, 0x46, 0x61, 0x8d, 0x51, 0x5c, 0x63, 0x9e, 0x43, 0xa8, 0x60, 0x40, 0x05, 0x88, 0x74,
	0xb5, 0x22, 0x3e, 0xf1, 0xb6, 0x72, 0x43, 0x17, 0x7a, 0x22, 0x3a, 0xd7, 0x70, 0x00, 0x1a, 0x61,
	0xe2, 0x45, 0x2c, 0x95, 0x9b, 0xba, 0xd0, 0x6b, 0x0d, 0xee, 0xbf, 0x39, 0x67, 0xc2, 0xb1, 0xe1,
	0xe5, 0xeb, 0xa3, 0x56, 0x43, 0x25, 0x13, 0xf6, 0x41, 0x3d, 0xf5, 0x69, 0x8c, 0x65, 0x91, 0x4b,
	0xfe, 0x7f, 0x74, 0x0e, 0x95, 0x8a, 0x82, 0x07, 0x3f, 0x07, 0x4d, 0x3f, 0xc1, 0x1e, 0xc3, 0x81,
	0x7c, 0xc5, 0x25, 0x8a, 0x51, 0x24, 0x62, 0x9c, 0x12, 0x31, 0xdc, 0x53, 0x22, 0x43, 0x31, 0x57,
	0xfe, 0xf4, 0xbb, 0x26, 0xa0, 0x93, 0x08, 0x7e, 0x06, 0x44, 0x2f, 0xf1, 0xd7, 0xe4, 0x0e, 0x07,
	0x32, 0x78, 0xe7, 0x80, 0x4b, 0x2e, 0x3e, 0x2b, 0xba, 0x36, 0x68, 0x55, 0x36, 0xcb, 0xb3, 0xf3,
	0xe2, 0x78, 0x4b, 0x7c, 0x8f, 0x67, 0x27, 0x70, 0x43, 0xaa, 0x2d, 0x28, 0x83, 0x66, 0x9c, 0xd0,
	0x15, 0xd9, 0x62, 0x9e, 0xac, 0x88, 0x4e, 0x65, 0xf7, 0x3b, 0xd0, 0xae, 0xfa, 0x02, 0x9f, 0x00,
	0xe8, 0xed, 0xd8, 0x9a, 0x26, 0xe4, 0x5b, 0x2e, 0x5d, 0xf8, 0x34, 0xc0, 0xe5, 0xc8, 0xce, 0x1b,
	0xc8, 0x88, 0x06, 0x3c, 0x88, 0xd8, 0x4b, 0xd3, 0x57, 0x34, 0x09, 0xca, 0xc9, 0xe7, 0x1a, 0x3e,
	0x04, 0xd7, 0x09, 0x5e, 0x25, 0x38, 0x5d, 0x2f, 0x18, 0xdd, 0xe0, 0x88, 0xbf, 0x1b, 0x11, 0xb5,
	0xcb, 0xa6, 0x9b, 0xf7, 0x1e, 0xb3, 0xf3, 0x55, 0x78, 0xb0, 0x1f, 0x82, 0xa6, 0x63, 0x4d, 0xc7,
	0xf6, 0x74, 0x22, 0xd5, 0x14, 0x69, 0x7f, 0xd0, 0xdb, 0xbc, 0xef, 0xe0, 0x28, 0x20, 0x51, 0x08,
	0x35, 0x20, 0x9a, 0x8e, 0x83, 0x66, 0x5f, 0x59, 0x63, 0x49, 0x50, 0x3a, 0xfb, 0x83, 0x7e, 0xcd,
	0x71, 0x33, 0x8e, 0x13, 0x7a, 0x87, 0x83, 0x9c, 0x80, 0xac, 0x2f, 0xac, 0x91, 0x6b, 0x8d, 0xa5,
	0x8b, 0x0a, 0x01, 0xe1, 0x6f, 0xb0, 0xcf, 0x70, 0xa0, 0x5c, 0xfe, 0xf0, 0xb3, 0x5a, 0x7b, 0x3c,
	0x07, 0xf5, 0xc2, 0xba, 0x8f, 0x41, 0xcb, 0x74, 0x9c, 0x17, 0xf6, 0xc8, 0x74, 0xed, 0xd9, 0x54,
	0xaa, 0x29, 0xf7, 0xf7, 0x07, 0x5d, 0xe2, 0x98, 0x59, 0xf1, 0x2f, 0x5f, 0x0b, 0xcd, 0x9e, 0xd9,
	0x2f, 0x2c, 0x49, 0x28, 0xd7, 0xca, 0x29, 0x4e, 0x61, 0x62, 0x39, 0xf4, 0x47, 0x01, 0xd4, 0xb9,
	0x8b, 0x70, 0x00, 0xa0, 0x79, 0xe3, 0x3e, 0x9f, 0x21, 0xfb, 0x25, 0x9f, 0xbb, 0x18, 0xcd, 0xc6,
	0x96, 0x54, 0x53, 0x94, 0xfd, 0x41, 0x7f, 0xc0, 0x29, 0xe6, 0x5b, 0x4e, 0x6a, 0x40, 0x74, 0xcc,
	0xf9, 0xfc, 0xeb, 0x19, 0x3a, 0x5f, 0x8d, 0x33, 0x9d, 0x93, 0x9d, 0x3d, 0x70, 0x8d, 0xac, 0x67,
	0xc8, 0x9a, 0x3f, 0x5f, 0xb8, 0xb3, 0x2f, 0xad, 0xa9, 0x74, 0xa1, 0x7c, 0xb0, 0x3f, 0xe8, 0x1d,
	0xce, 0x42, 0x15, 0x4f, 0x8b, 0x75, 0x86, 0x93, 0x5f, 0xff, 0x54, 0x6b, 0xdf, 0x67, 0xaa, 0xf0,
	0x3a, 0x53, 0x85, 0x5f, 0x32, 0x55, 0xf8, 0x23, 0x53, 0x85, 0xbf, 0x32, 0xb5, 0xf6, 0x77, 0xa6,
	0x0a, 0x2f, 0x1f, 0xbd, 0xeb, 0x4b, 0x15, 0x6f, 0xc2, 0xfc, 0x37, 0x5e, 0x2e, 0x1b, 0xfc, 0x45,
	0x3e, 0xfd, 0x37, 0x00, 0x00, 0xff, 0xff, 0x39, 0xbc, 0x95, 0x15, 0xdd, 0x04, 0x00, 0x00,
}
