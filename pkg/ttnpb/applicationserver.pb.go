// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lorawan-stack/api/applicationserver.proto

package ttnpb

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
	time "time"

	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ApplicationLink struct {
	// The address of the external Network Server where to link to.
	// The typical format of the address is "host:port". If the port is omitted,
	// the normal port inference (with DNS lookup, otherwise defaults) is used.
	// Leave empty when linking to a cluster Network Server.
	NetworkServerAddress string `protobuf:"bytes,1,opt,name=network_server_address,json=networkServerAddress,proto3" json:"network_server_address,omitempty"`
	// The API key to use to link the Application Server to Network Server.
	// This API key needs to have RIGHT_APPLICATION_LINK.
	APIKey string `protobuf:"bytes,2,opt,name=api_key,json=apiKey,proto3" json:"api_key,omitempty"`
	// Default message payload formatters to use when there are no formatters
	// defined on the end device level.
	DefaultFormatters *MessagePayloadFormatters `protobuf:"bytes,3,opt,name=default_formatters,json=defaultFormatters,proto3" json:"default_formatters,omitempty"`
	// Enable TLS for linking to the external Network Server.
	// For cluster-local Network Servers, the cluster's TLS setting is used.
	TLS bool `protobuf:"varint,4,opt,name=tls,proto3" json:"tls,omitempty"`
	// Skip decryption of uplink payloads and encryption of downlink payloads.
	// Leave empty for the using the Application Server's default setting.
	SkipPayloadCrypto    *types.BoolValue `protobuf:"bytes,5,opt,name=skip_payload_crypto,json=skipPayloadCrypto,proto3" json:"skip_payload_crypto,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ApplicationLink) Reset()      { *m = ApplicationLink{} }
func (*ApplicationLink) ProtoMessage() {}
func (*ApplicationLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_df9d75a19dc066e1, []int{0}
}
func (m *ApplicationLink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplicationLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplicationLink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplicationLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationLink.Merge(m, src)
}
func (m *ApplicationLink) XXX_Size() int {
	return m.Size()
}
func (m *ApplicationLink) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationLink.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationLink proto.InternalMessageInfo

func (m *ApplicationLink) GetNetworkServerAddress() string {
	if m != nil {
		return m.NetworkServerAddress
	}
	return ""
}

func (m *ApplicationLink) GetAPIKey() string {
	if m != nil {
		return m.APIKey
	}
	return ""
}

func (m *ApplicationLink) GetDefaultFormatters() *MessagePayloadFormatters {
	if m != nil {
		return m.DefaultFormatters
	}
	return nil
}

func (m *ApplicationLink) GetTLS() bool {
	if m != nil {
		return m.TLS
	}
	return false
}

func (m *ApplicationLink) GetSkipPayloadCrypto() *types.BoolValue {
	if m != nil {
		return m.SkipPayloadCrypto
	}
	return nil
}

type GetApplicationLinkRequest struct {
	ApplicationIdentifiers `protobuf:"bytes,1,opt,name=application_ids,json=applicationIds,proto3,embedded=application_ids" json:"application_ids"`
	FieldMask              types.FieldMask `protobuf:"bytes,2,opt,name=field_mask,json=fieldMask,proto3" json:"field_mask"`
	XXX_NoUnkeyedLiteral   struct{}        `json:"-"`
	XXX_sizecache          int32           `json:"-"`
}

func (m *GetApplicationLinkRequest) Reset()      { *m = GetApplicationLinkRequest{} }
func (*GetApplicationLinkRequest) ProtoMessage() {}
func (*GetApplicationLinkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_df9d75a19dc066e1, []int{1}
}
func (m *GetApplicationLinkRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetApplicationLinkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetApplicationLinkRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetApplicationLinkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetApplicationLinkRequest.Merge(m, src)
}
func (m *GetApplicationLinkRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetApplicationLinkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetApplicationLinkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetApplicationLinkRequest proto.InternalMessageInfo

func (m *GetApplicationLinkRequest) GetFieldMask() types.FieldMask {
	if m != nil {
		return m.FieldMask
	}
	return types.FieldMask{}
}

type SetApplicationLinkRequest struct {
	ApplicationIdentifiers `protobuf:"bytes,1,opt,name=application_ids,json=applicationIds,proto3,embedded=application_ids" json:"application_ids"`
	ApplicationLink        `protobuf:"bytes,2,opt,name=link,proto3,embedded=link" json:"link"`
	FieldMask              types.FieldMask `protobuf:"bytes,3,opt,name=field_mask,json=fieldMask,proto3" json:"field_mask"`
	XXX_NoUnkeyedLiteral   struct{}        `json:"-"`
	XXX_sizecache          int32           `json:"-"`
}

func (m *SetApplicationLinkRequest) Reset()      { *m = SetApplicationLinkRequest{} }
func (*SetApplicationLinkRequest) ProtoMessage() {}
func (*SetApplicationLinkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_df9d75a19dc066e1, []int{2}
}
func (m *SetApplicationLinkRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetApplicationLinkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetApplicationLinkRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetApplicationLinkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetApplicationLinkRequest.Merge(m, src)
}
func (m *SetApplicationLinkRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetApplicationLinkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetApplicationLinkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetApplicationLinkRequest proto.InternalMessageInfo

func (m *SetApplicationLinkRequest) GetFieldMask() types.FieldMask {
	if m != nil {
		return m.FieldMask
	}
	return types.FieldMask{}
}

// Link stats as monitored by the Application Server.
type ApplicationLinkStats struct {
	LinkedAt             *time.Time `protobuf:"bytes,1,opt,name=linked_at,json=linkedAt,proto3,stdtime" json:"linked_at,omitempty"`
	NetworkServerAddress string     `protobuf:"bytes,2,opt,name=network_server_address,json=networkServerAddress,proto3" json:"network_server_address,omitempty"`
	// Timestamp when the last upstream message has been received from a Network Server.
	// This can be a join-accept, uplink message or downlink message event.
	LastUpReceivedAt *time.Time `protobuf:"bytes,3,opt,name=last_up_received_at,json=lastUpReceivedAt,proto3,stdtime" json:"last_up_received_at,omitempty"`
	// Number of upstream messages received.
	UpCount uint64 `protobuf:"varint,4,opt,name=up_count,json=upCount,proto3" json:"up_count,omitempty"`
	// Timestamp when the last downlink message has been forwarded to a Network Server.
	LastDownlinkForwardedAt *time.Time `protobuf:"bytes,5,opt,name=last_downlink_forwarded_at,json=lastDownlinkForwardedAt,proto3,stdtime" json:"last_downlink_forwarded_at,omitempty"`
	// Number of downlink messages forwarded.
	DownlinkCount        uint64   `protobuf:"varint,6,opt,name=downlink_count,json=downlinkCount,proto3" json:"downlink_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ApplicationLinkStats) Reset()      { *m = ApplicationLinkStats{} }
func (*ApplicationLinkStats) ProtoMessage() {}
func (*ApplicationLinkStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_df9d75a19dc066e1, []int{3}
}
func (m *ApplicationLinkStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplicationLinkStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplicationLinkStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplicationLinkStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationLinkStats.Merge(m, src)
}
func (m *ApplicationLinkStats) XXX_Size() int {
	return m.Size()
}
func (m *ApplicationLinkStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationLinkStats.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationLinkStats proto.InternalMessageInfo

func (m *ApplicationLinkStats) GetLinkedAt() *time.Time {
	if m != nil {
		return m.LinkedAt
	}
	return nil
}

func (m *ApplicationLinkStats) GetNetworkServerAddress() string {
	if m != nil {
		return m.NetworkServerAddress
	}
	return ""
}

func (m *ApplicationLinkStats) GetLastUpReceivedAt() *time.Time {
	if m != nil {
		return m.LastUpReceivedAt
	}
	return nil
}

func (m *ApplicationLinkStats) GetUpCount() uint64 {
	if m != nil {
		return m.UpCount
	}
	return 0
}

func (m *ApplicationLinkStats) GetLastDownlinkForwardedAt() *time.Time {
	if m != nil {
		return m.LastDownlinkForwardedAt
	}
	return nil
}

func (m *ApplicationLinkStats) GetDownlinkCount() uint64 {
	if m != nil {
		return m.DownlinkCount
	}
	return 0
}

type NsAsHandleUplinkRequest struct {
	ApplicationUps       []*ApplicationUp `protobuf:"bytes,1,rep,name=application_ups,json=applicationUps,proto3" json:"application_ups,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *NsAsHandleUplinkRequest) Reset()      { *m = NsAsHandleUplinkRequest{} }
func (*NsAsHandleUplinkRequest) ProtoMessage() {}
func (*NsAsHandleUplinkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_df9d75a19dc066e1, []int{4}
}
func (m *NsAsHandleUplinkRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NsAsHandleUplinkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NsAsHandleUplinkRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NsAsHandleUplinkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NsAsHandleUplinkRequest.Merge(m, src)
}
func (m *NsAsHandleUplinkRequest) XXX_Size() int {
	return m.Size()
}
func (m *NsAsHandleUplinkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NsAsHandleUplinkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NsAsHandleUplinkRequest proto.InternalMessageInfo

func (m *NsAsHandleUplinkRequest) GetApplicationUps() []*ApplicationUp {
	if m != nil {
		return m.ApplicationUps
	}
	return nil
}

func init() {
	proto.RegisterType((*ApplicationLink)(nil), "ttn.lorawan.v3.ApplicationLink")
	golang_proto.RegisterType((*ApplicationLink)(nil), "ttn.lorawan.v3.ApplicationLink")
	proto.RegisterType((*GetApplicationLinkRequest)(nil), "ttn.lorawan.v3.GetApplicationLinkRequest")
	golang_proto.RegisterType((*GetApplicationLinkRequest)(nil), "ttn.lorawan.v3.GetApplicationLinkRequest")
	proto.RegisterType((*SetApplicationLinkRequest)(nil), "ttn.lorawan.v3.SetApplicationLinkRequest")
	golang_proto.RegisterType((*SetApplicationLinkRequest)(nil), "ttn.lorawan.v3.SetApplicationLinkRequest")
	proto.RegisterType((*ApplicationLinkStats)(nil), "ttn.lorawan.v3.ApplicationLinkStats")
	golang_proto.RegisterType((*ApplicationLinkStats)(nil), "ttn.lorawan.v3.ApplicationLinkStats")
	proto.RegisterType((*NsAsHandleUplinkRequest)(nil), "ttn.lorawan.v3.NsAsHandleUplinkRequest")
	golang_proto.RegisterType((*NsAsHandleUplinkRequest)(nil), "ttn.lorawan.v3.NsAsHandleUplinkRequest")
}

func init() {
	proto.RegisterFile("lorawan-stack/api/applicationserver.proto", fileDescriptor_df9d75a19dc066e1)
}
func init() {
	golang_proto.RegisterFile("lorawan-stack/api/applicationserver.proto", fileDescriptor_df9d75a19dc066e1)
}

var fileDescriptor_df9d75a19dc066e1 = []byte{
	// 1491 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0x4d, 0x6c, 0x13, 0x47,
	0x1b, 0xde, 0xb1, 0x9d, 0xbf, 0x81, 0x2f, 0x24, 0x0b, 0x1f, 0x24, 0xfe, 0xf8, 0x36, 0xd1, 0x42,
	0xa9, 0x63, 0xe1, 0x5d, 0x6a, 0xda, 0xaa, 0x4d, 0xd5, 0x46, 0x36, 0x84, 0xf0, 0x93, 0x94, 0x60,
	0x27, 0x45, 0x0a, 0x3f, 0xd6, 0xc4, 0x9e, 0x38, 0x2b, 0xaf, 0x77, 0x87, 0x9d, 0xd9, 0x04, 0x03,
	0x91, 0x50, 0x55, 0x51, 0xc4, 0xa1, 0x45, 0x54, 0x48, 0x1c, 0x5b, 0x55, 0x95, 0x38, 0xa2, 0xf6,
	0x50, 0x4e, 0x2d, 0x52, 0x85, 0x84, 0xda, 0x0b, 0x55, 0x2f, 0x9c, 0x52, 0x62, 0xf7, 0x80, 0xd4,
	0x0b, 0x47, 0x94, 0x53, 0xb5, 0xb3, 0xeb, 0xf8, 0x2f, 0x3f, 0x86, 0x22, 0xaa, 0xde, 0x66, 0x77,
	0xde, 0xf7, 0x79, 0x9f, 0xf7, 0x9d, 0xe7, 0x19, 0xaf, 0xe1, 0x80, 0x6e, 0x5a, 0x68, 0x1e, 0x19,
	0x11, 0xca, 0x50, 0x3a, 0xa7, 0x22, 0xa2, 0xa9, 0x88, 0x10, 0x5d, 0x4b, 0x23, 0xa6, 0x99, 0x06,
	0xc5, 0xd6, 0x1c, 0xb6, 0x14, 0x62, 0x99, 0xcc, 0x14, 0x3b, 0x19, 0x33, 0x14, 0x2f, 0x5c, 0x99,
	0xdb, 0x1f, 0x8c, 0x65, 0x35, 0x36, 0x6b, 0x4f, 0x2b, 0x69, 0x33, 0xaf, 0x62, 0x63, 0xce, 0x2c,
	0x10, 0xcb, 0x3c, 0x5f, 0x50, 0x79, 0x70, 0x3a, 0x92, 0xc5, 0x46, 0x64, 0x0e, 0xe9, 0x5a, 0x06,
	0x31, 0xac, 0x36, 0x2c, 0x5c, 0xc8, 0x60, 0xa4, 0x0a, 0x22, 0x6b, 0x66, 0x4d, 0x37, 0x79, 0xda,
	0x9e, 0xe1, 0x4f, 0xfc, 0x81, 0xaf, 0xbc, 0xf0, 0x9d, 0x59, 0xd3, 0xcc, 0xea, 0xd8, 0x65, 0x69,
	0x18, 0x26, 0x73, 0x49, 0x7a, 0xbb, 0xff, 0xf3, 0x76, 0x57, 0x30, 0x70, 0x9e, 0xb0, 0x82, 0xb7,
	0xd9, 0x5f, 0xbf, 0x39, 0xa3, 0x61, 0x3d, 0x93, 0xca, 0x23, 0x9a, 0xf3, 0x22, 0xfa, 0xea, 0x23,
	0x98, 0x96, 0xc7, 0x94, 0xa1, 0x3c, 0xf1, 0x02, 0xa4, 0xfa, 0x80, 0x79, 0x0b, 0x11, 0x82, 0xad,
	0x72, 0x7d, 0xb9, 0x71, 0x94, 0xd8, 0xc8, 0xa4, 0x32, 0x78, 0x4e, 0x4b, 0x97, 0x1b, 0xde, 0xd5,
	0x18, 0xa3, 0x65, 0xb0, 0xc1, 0xb4, 0x19, 0xad, 0x02, 0xd4, 0xdf, 0x18, 0x94, 0xc7, 0x94, 0xa2,
	0x2c, 0x2e, 0x47, 0xec, 0x5c, 0x25, 0xe2, 0x1c, 0x63, 0xee, 0xae, 0x7c, 0xdf, 0x0f, 0xb7, 0xc4,
	0x2a, 0x87, 0x38, 0xaa, 0x19, 0x39, 0xf1, 0x3e, 0x80, 0xdb, 0x0d, 0xcc, 0xe6, 0x4d, 0x2b, 0x97,
	0x72, 0x4f, 0x35, 0x85, 0x32, 0x19, 0x0b, 0x53, 0xda, 0x03, 0xfa, 0x41, 0xa8, 0x23, 0xfe, 0x19,
	0x58, 0x8e, 0x5f, 0x03, 0xd6, 0xa7, 0x20, 0xfa, 0x09, 0x38, 0x1b, 0x1a, 0x1a, 0x0c, 0x0d, 0x0d,
	0x9e, 0x42, 0x91, 0x0b, 0xb1, 0xc8, 0xd4, 0xbe, 0xc8, 0xbb, 0x67, 0x2e, 0x55, 0xad, 0x2b, 0xcb,
	0xd3, 0x91, 0x33, 0xe1, 0xaa, 0x8d, 0x81, 0xd3, 0xca, 0x40, 0xd8, 0xc9, 0x8b, 0x45, 0xa6, 0x50,
	0xe4, 0x82, 0x9b, 0x57, 0x59, 0x57, 0x96, 0x3c, 0xaf, 0xb2, 0x31, 0x10, 0x1a, 0x1a, 0x1c, 0x3c,
	0xe5, 0xac, 0x2e, 0xbe, 0xb1, 0xf7, 0xad, 0x85, 0x81, 0xa1, 0xdd, 0x97, 0xce, 0xee, 0x4e, 0x6c,
	0xf3, 0xe8, 0x26, 0x39, 0xdb, 0x98, 0x4b, 0x56, 0x0c, 0xc3, 0x36, 0x44, 0xb4, 0x54, 0x0e, 0x17,
	0x7a, 0x7c, 0x9c, 0x77, 0xf7, 0x72, 0x3c, 0x60, 0xf9, 0xba, 0x40, 0x71, 0xb1, 0xaf, 0x35, 0x36,
	0x7e, 0xe4, 0x18, 0x2e, 0x24, 0x5a, 0x11, 0xd1, 0x8e, 0xe1, 0x82, 0x78, 0x12, 0x8a, 0x19, 0x3c,
	0x83, 0x6c, 0x9d, 0xa5, 0x66, 0x4c, 0x2b, 0x8f, 0x18, 0xc3, 0x16, 0xed, 0xf1, 0xf7, 0x83, 0xd0,
	0xa6, 0x68, 0x48, 0xa9, 0x55, 0xb3, 0x32, 0xe6, 0x4e, 0x78, 0x1c, 0x15, 0x74, 0x13, 0x65, 0x0e,
	0xad, 0xc4, 0x27, 0xba, 0x3d, 0x8c, 0xca, 0x2b, 0xb1, 0x17, 0xfa, 0x99, 0x4e, 0x7b, 0x02, 0xfd,
	0x20, 0xd4, 0x1e, 0x6f, 0x2b, 0x2e, 0xf6, 0xf9, 0x27, 0x46, 0x93, 0x09, 0xe7, 0x9d, 0x78, 0x14,
	0x6e, 0xa5, 0x39, 0x8d, 0xa4, 0x88, 0x8b, 0x93, 0x4a, 0x5b, 0x05, 0xc2, 0xcc, 0x9e, 0x16, 0x5e,
	0x34, 0xa8, 0xb8, 0x12, 0x52, 0xca, 0x12, 0x52, 0xe2, 0xa6, 0xa9, 0x7f, 0x84, 0x74, 0x1b, 0x27,
	0xba, 0x9d, 0x34, 0xaf, 0xfa, 0x01, 0x9e, 0x24, 0xff, 0x08, 0x60, 0xef, 0x08, 0x66, 0x75, 0x47,
	0x99, 0xc0, 0xe7, 0x6c, 0x4c, 0x99, 0x88, 0xe0, 0x96, 0x2a, 0xa7, 0xa6, 0xb4, 0x8c, 0x7b, 0x92,
	0x9b, 0xa2, 0x7b, 0xea, 0x5b, 0xab, 0x02, 0x38, 0x52, 0x11, 0x5b, 0xbc, 0x6b, 0x39, 0xde, 0x72,
	0x0d, 0xf8, 0xba, 0xc0, 0x83, 0xc5, 0x3e, 0xe1, 0xe1, 0x62, 0x1f, 0x48, 0x74, 0xa2, 0xea, 0x48,
	0x2a, 0x0e, 0x41, 0x58, 0xb1, 0x09, 0x9f, 0xf7, 0x6a, 0x3d, 0x1c, 0x72, 0x42, 0xc6, 0x10, 0xcd,
	0xc5, 0x03, 0x0e, 0x52, 0xa2, 0x63, 0xa6, 0xfc, 0x42, 0xbe, 0xe2, 0x83, 0xbd, 0xc9, 0x7f, 0xb2,
	0x83, 0x61, 0x18, 0xd0, 0x35, 0xa3, 0xcc, 0xbd, 0x6f, 0x1d, 0x5c, 0x87, 0xd8, 0x2a, 0x80, 0x3c,
	0xbd, 0x6e, 0x10, 0xfe, 0xe7, 0x1f, 0xc4, 0xe7, 0x01, 0xb8, 0xad, 0xae, 0x58, 0x92, 0x21, 0x46,
	0xc5, 0xf7, 0x61, 0x87, 0x53, 0x01, 0x67, 0x52, 0x88, 0x79, 0xdd, 0x37, 0x02, 0x4f, 0x94, 0x6f,
	0xa2, 0x78, 0xe0, 0xfa, 0xef, 0x7d, 0x20, 0xd1, 0xee, 0xa6, 0xc4, 0xd8, 0x7a, 0xb6, 0xf6, 0xfd,
	0x9b, 0x6c, 0x7d, 0x1c, 0x6e, 0xd5, 0x11, 0x65, 0x29, 0x9b, 0xa4, 0x2c, 0x9c, 0xc6, 0xda, 0x9c,
	0x3b, 0x10, 0x7f, 0x93, 0x03, 0xe9, 0x72, 0x92, 0x27, 0x49, 0xc2, 0x4b, 0x8d, 0x31, 0xb1, 0x17,
	0xb6, 0xdb, 0x24, 0x95, 0x36, 0x6d, 0x83, 0x71, 0x9f, 0x06, 0x12, 0x6d, 0x36, 0x39, 0xe0, 0x3c,
	0x8a, 0x67, 0x60, 0x90, 0xd7, 0xca, 0x98, 0xf3, 0x86, 0x33, 0x48, 0xe7, 0x72, 0x98, 0x47, 0x56,
	0xc6, 0x2d, 0xd9, 0xd2, 0x64, 0xc9, 0x1d, 0x0e, 0xc6, 0x41, 0x0f, 0xe2, 0x50, 0x19, 0x21, 0xc6,
	0xc4, 0xd7, 0x60, 0xe7, 0x0a, 0xb2, 0x5b, 0xbf, 0x95, 0xd7, 0xff, 0x4f, 0xf9, 0x2d, 0x67, 0x21,
	0xe7, 0xe0, 0x8e, 0x0f, 0x69, 0x8c, 0x1e, 0x46, 0x46, 0x46, 0xc7, 0x93, 0x44, 0xaf, 0xf2, 0xc5,
	0x78, 0xad, 0x2f, 0x6c, 0xe2, 0xf8, 0xc2, 0x1f, 0xda, 0x14, 0xfd, 0xff, 0x3a, 0xfa, 0x9d, 0x24,
	0xf1, 0xf6, 0xe5, 0x78, 0xcb, 0x0d, 0xe0, 0x6b, 0xaf, 0xb5, 0xc1, 0x24, 0xa1, 0xd1, 0x9f, 0x03,
	0xd0, 0x17, 0xa3, 0xe2, 0x4d, 0x00, 0xdb, 0x46, 0x30, 0xe3, 0x3f, 0x08, 0x03, 0xf5, 0x58, 0x6b,
	0xde, 0x34, 0xc1, 0x8d, 0x6c, 0x23, 0x7f, 0xf0, 0xf1, 0x6f, 0x7f, 0x7c, 0xe1, 0x7b, 0x47, 0x7c,
	0x5b, 0x45, 0xb4, 0xe6, 0xf3, 0x41, 0xbd, 0x58, 0x67, 0x70, 0xa5, 0xf6, 0x79, 0x41, 0xe5, 0xf6,
	0xba, 0x05, 0x60, 0x5b, 0x72, 0x2d, 0x5e, 0xc9, 0x17, 0xe7, 0x15, 0xe3, 0xbc, 0xde, 0x0b, 0xbe,
	0x20, 0xaf, 0x41, 0x10, 0x16, 0x2f, 0x41, 0x78, 0x10, 0xeb, 0x98, 0x61, 0x4e, 0xae, 0xc9, 0x8b,
	0x29, 0xb8, 0xbd, 0x41, 0x3e, 0xc3, 0xce, 0xb7, 0x88, 0xac, 0x70, 0x42, 0xa1, 0xf0, 0x9e, 0x8d,
	0x08, 0x79, 0x83, 0xb9, 0x01, 0xe0, 0x66, 0xef, 0xc0, 0xdc, 0xeb, 0xa2, 0x59, 0x02, 0xbb, 0x37,
	0x18, 0x0d, 0x47, 0x93, 0xdf, 0xe4, 0x74, 0x14, 0x71, 0x6f, 0x73, 0x74, 0x54, 0xea, 0x64, 0x45,
	0x4f, 0xc2, 0x80, 0xa3, 0x5c, 0xf1, 0x38, 0xdc, 0x5c, 0xad, 0x5e, 0xf1, 0xf5, 0xfa, 0x9a, 0x6b,
	0xe8, 0x7b, 0xad, 0xe9, 0x44, 0xbf, 0x6a, 0x87, 0x2d, 0x31, 0x42, 0x62, 0x54, 0x9c, 0x80, 0x1d,
	0x49, 0x7b, 0x9a, 0xa6, 0x2d, 0x6d, 0x1a, 0x37, 0xdd, 0xf3, 0xfa, 0xee, 0xd8, 0x07, 0xc4, 0x5f,
	0x00, 0xec, 0x2e, 0x3b, 0xf6, 0x84, 0x8d, 0x6d, 0x3c, 0x6e, 0xd3, 0x59, 0xb1, 0x61, 0x54, 0x35,
	0x21, 0x1b, 0x70, 0x96, 0xcf, 0xf3, 0x11, 0x5a, 0x72, 0xbe, 0x71, 0x84, 0x95, 0x8f, 0xbf, 0x55,
	0x14, 0xd6, 0xa8, 0x38, 0x37, 0xb4, 0x31, 0x6f, 0x65, 0xb9, 0xa0, 0x3a, 0x37, 0x88, 0x4a, 0x6c,
	0x3a, 0xeb, 0x28, 0xf3, 0x57, 0x00, 0xb7, 0xd5, 0x51, 0x25, 0x3a, 0x4a, 0xe3, 0xbf, 0xd9, 0xd0,
	0x45, 0xde, 0x90, 0x2d, 0x93, 0x57, 0xd6, 0x90, 0xe5, 0xf2, 0x76, 0x7a, 0xfa, 0xae, 0xfe, 0x84,
	0x46, 0x35, 0xca, 0x1a, 0x1b, 0x1a, 0x36, 0x32, 0x07, 0x39, 0x48, 0xb3, 0x92, 0x2f, 0x63, 0x52,
	0x39, 0xc1, 0xdb, 0x1b, 0x15, 0x8f, 0x3e, 0xff, 0x95, 0xb0, 0xd2, 0x4f, 0x5d, 0x03, 0xe2, 0xd7,
	0x00, 0xfe, 0x77, 0x04, 0xb3, 0xb1, 0x13, 0x13, 0x13, 0x07, 0x4c, 0xc3, 0xc0, 0x69, 0xae, 0x4c,
	0x63, 0xc6, 0x6c, 0x5a, 0xba, 0x72, 0xc3, 0xd7, 0x68, 0x03, 0x56, 0xf3, 0x97, 0xec, 0x02, 0xff,
	0x2f, 0x10, 0x49, 0xaf, 0xa4, 0x47, 0x34, 0x87, 0xcb, 0x4f, 0x00, 0x76, 0x26, 0xb5, 0xbc, 0xad,
	0x23, 0x56, 0x76, 0xec, 0xfa, 0x8e, 0x59, 0x53, 0x22, 0x17, 0x38, 0x13, 0x26, 0x9b, 0xaf, 0x42,
	0x22, 0x36, 0x51, 0xa9, 0xc7, 0x7a, 0x10, 0x84, 0xa3, 0x7f, 0x06, 0xe0, 0xd6, 0x18, 0x5d, 0x11,
	0x40, 0x02, 0x67, 0x35, 0xca, 0xac, 0x82, 0xf8, 0x2d, 0x80, 0xfe, 0x11, 0xcc, 0xc4, 0x5d, 0xab,
	0xfc, 0xac, 0x55, 0x45, 0xbb, 0xda, 0xef, 0x5d, 0x53, 0x50, 0x72, 0x8e, 0xf7, 0x86, 0xc5, 0xf4,
	0x2b, 0xe8, 0x4d, 0xbc, 0xe2, 0x83, 0xfe, 0xe4, 0x6a, 0xa4, 0x93, 0xcf, 0x47, 0xfa, 0x07, 0xc0,
	0x59, 0x7f, 0x0f, 0x82, 0xeb, 0xd2, 0x56, 0x5e, 0x90, 0xb6, 0x52, 0x4b, 0x7b, 0x10, 0x84, 0xa7,
	0xc6, 0xe4, 0xc3, 0x2f, 0xab, 0x92, 0xe3, 0xfb, 0x9b, 0x00, 0xb6, 0xba, 0x3f, 0xb3, 0x4d, 0x9a,
	0x7d, 0x2d, 0x69, 0x8e, 0xf1, 0x41, 0x8c, 0x84, 0x87, 0x5f, 0x8a, 0xbd, 0xe3, 0xdf, 0x80, 0x07,
	0x4b, 0x12, 0x78, 0xb8, 0x24, 0x81, 0x47, 0x4b, 0x92, 0xf0, 0x78, 0x49, 0x12, 0x9e, 0x2c, 0x49,
	0xc2, 0xd3, 0x25, 0x49, 0x78, 0xb6, 0x24, 0x81, 0xcb, 0x45, 0x09, 0x5c, 0x2d, 0x4a, 0xc2, 0xed,
	0xa2, 0x04, 0xee, 0x14, 0x25, 0xe1, 0x6e, 0x51, 0x12, 0xee, 0x15, 0x25, 0xe1, 0x41, 0x51, 0x02,
	0x0f, 0x8b, 0x12, 0x78, 0x54, 0x94, 0x84, 0xc7, 0x45, 0x09, 0x3c, 0x29, 0x4a, 0xc2, 0xd3, 0xa2,
	0x04, 0x9e, 0x15, 0x25, 0xe1, 0x72, 0x49, 0x12, 0xae, 0x96, 0x24, 0x70, 0xbd, 0x24, 0x09, 0xb7,
	0x4a, 0x12, 0xf8, 0xb2, 0x24, 0x09, 0xb7, 0x4b, 0x92, 0x70, 0xa7, 0x24, 0x81, 0xbb, 0x25, 0x09,
	0xdc, 0x2b, 0x49, 0x60, 0x4a, 0xcd, 0x9a, 0x0a, 0x9b, 0xc5, 0x6c, 0x56, 0x33, 0xb2, 0x54, 0xf1,
	0x3e, 0x98, 0xd5, 0xda, 0xff, 0xfc, 0x73, 0xfb, 0x55, 0x92, 0xcb, 0xaa, 0x8c, 0x19, 0x64, 0x7a,
	0xba, 0x95, 0x8f, 0x61, 0xff, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x5e, 0xa7, 0xf0, 0x98, 0xce,
	0x11, 0x00, 0x00,
}

func (this *ApplicationLink) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplicationLink)
	if !ok {
		that2, ok := that.(ApplicationLink)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NetworkServerAddress != that1.NetworkServerAddress {
		return false
	}
	if this.APIKey != that1.APIKey {
		return false
	}
	if !this.DefaultFormatters.Equal(that1.DefaultFormatters) {
		return false
	}
	if this.TLS != that1.TLS {
		return false
	}
	if !this.SkipPayloadCrypto.Equal(that1.SkipPayloadCrypto) {
		return false
	}
	return true
}
func (this *GetApplicationLinkRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetApplicationLinkRequest)
	if !ok {
		that2, ok := that.(GetApplicationLinkRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ApplicationIdentifiers.Equal(&that1.ApplicationIdentifiers) {
		return false
	}
	if !this.FieldMask.Equal(&that1.FieldMask) {
		return false
	}
	return true
}
func (this *SetApplicationLinkRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SetApplicationLinkRequest)
	if !ok {
		that2, ok := that.(SetApplicationLinkRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ApplicationIdentifiers.Equal(&that1.ApplicationIdentifiers) {
		return false
	}
	if !this.ApplicationLink.Equal(&that1.ApplicationLink) {
		return false
	}
	if !this.FieldMask.Equal(&that1.FieldMask) {
		return false
	}
	return true
}
func (this *ApplicationLinkStats) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplicationLinkStats)
	if !ok {
		that2, ok := that.(ApplicationLinkStats)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.LinkedAt == nil {
		if this.LinkedAt != nil {
			return false
		}
	} else if !this.LinkedAt.Equal(*that1.LinkedAt) {
		return false
	}
	if this.NetworkServerAddress != that1.NetworkServerAddress {
		return false
	}
	if that1.LastUpReceivedAt == nil {
		if this.LastUpReceivedAt != nil {
			return false
		}
	} else if !this.LastUpReceivedAt.Equal(*that1.LastUpReceivedAt) {
		return false
	}
	if this.UpCount != that1.UpCount {
		return false
	}
	if that1.LastDownlinkForwardedAt == nil {
		if this.LastDownlinkForwardedAt != nil {
			return false
		}
	} else if !this.LastDownlinkForwardedAt.Equal(*that1.LastDownlinkForwardedAt) {
		return false
	}
	if this.DownlinkCount != that1.DownlinkCount {
		return false
	}
	return true
}
func (this *NsAsHandleUplinkRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NsAsHandleUplinkRequest)
	if !ok {
		that2, ok := that.(NsAsHandleUplinkRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ApplicationUps) != len(that1.ApplicationUps) {
		return false
	}
	for i := range this.ApplicationUps {
		if !this.ApplicationUps[i].Equal(that1.ApplicationUps[i]) {
			return false
		}
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AsClient is the client API for As service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AsClient interface {
	// Get a link configuration from the Application Server to Network Server.
	// This only contains the configuration. Use GetLinkStats to view statistics and any link errors.
	GetLink(ctx context.Context, in *GetApplicationLinkRequest, opts ...grpc.CallOption) (*ApplicationLink, error)
	// Set a link configuration from the Application Server a Network Server.
	// This call returns immediately after setting the link configuration; it does not wait for a link to establish.
	// To get link statistics or errors, use GetLinkStats.
	// Note that there can only be one Application Server instance linked to a Network Server for a given application at a time.
	SetLink(ctx context.Context, in *SetApplicationLinkRequest, opts ...grpc.CallOption) (*ApplicationLink, error)
	// Delete the link between the Application Server and Network Server for the specified application.
	DeleteLink(ctx context.Context, in *ApplicationIdentifiers, opts ...grpc.CallOption) (*types.Empty, error)
	// GetLinkStats returns the link statistics.
	// This call returns a NotFound error code if there is no link for the given application identifiers.
	// This call returns the error code of the link error if linking to a Network Server failed.
	GetLinkStats(ctx context.Context, in *ApplicationIdentifiers, opts ...grpc.CallOption) (*ApplicationLinkStats, error)
}

type asClient struct {
	cc *grpc.ClientConn
}

func NewAsClient(cc *grpc.ClientConn) AsClient {
	return &asClient{cc}
}

func (c *asClient) GetLink(ctx context.Context, in *GetApplicationLinkRequest, opts ...grpc.CallOption) (*ApplicationLink, error) {
	out := new(ApplicationLink)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.As/GetLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asClient) SetLink(ctx context.Context, in *SetApplicationLinkRequest, opts ...grpc.CallOption) (*ApplicationLink, error) {
	out := new(ApplicationLink)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.As/SetLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asClient) DeleteLink(ctx context.Context, in *ApplicationIdentifiers, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.As/DeleteLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asClient) GetLinkStats(ctx context.Context, in *ApplicationIdentifiers, opts ...grpc.CallOption) (*ApplicationLinkStats, error) {
	out := new(ApplicationLinkStats)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.As/GetLinkStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AsServer is the server API for As service.
type AsServer interface {
	// Get a link configuration from the Application Server to Network Server.
	// This only contains the configuration. Use GetLinkStats to view statistics and any link errors.
	GetLink(context.Context, *GetApplicationLinkRequest) (*ApplicationLink, error)
	// Set a link configuration from the Application Server a Network Server.
	// This call returns immediately after setting the link configuration; it does not wait for a link to establish.
	// To get link statistics or errors, use GetLinkStats.
	// Note that there can only be one Application Server instance linked to a Network Server for a given application at a time.
	SetLink(context.Context, *SetApplicationLinkRequest) (*ApplicationLink, error)
	// Delete the link between the Application Server and Network Server for the specified application.
	DeleteLink(context.Context, *ApplicationIdentifiers) (*types.Empty, error)
	// GetLinkStats returns the link statistics.
	// This call returns a NotFound error code if there is no link for the given application identifiers.
	// This call returns the error code of the link error if linking to a Network Server failed.
	GetLinkStats(context.Context, *ApplicationIdentifiers) (*ApplicationLinkStats, error)
}

// UnimplementedAsServer can be embedded to have forward compatible implementations.
type UnimplementedAsServer struct {
}

func (*UnimplementedAsServer) GetLink(ctx context.Context, req *GetApplicationLinkRequest) (*ApplicationLink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLink not implemented")
}
func (*UnimplementedAsServer) SetLink(ctx context.Context, req *SetApplicationLinkRequest) (*ApplicationLink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLink not implemented")
}
func (*UnimplementedAsServer) DeleteLink(ctx context.Context, req *ApplicationIdentifiers) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLink not implemented")
}
func (*UnimplementedAsServer) GetLinkStats(ctx context.Context, req *ApplicationIdentifiers) (*ApplicationLinkStats, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLinkStats not implemented")
}

func RegisterAsServer(s *grpc.Server, srv AsServer) {
	s.RegisterService(&_As_serviceDesc, srv)
}

func _As_GetLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetApplicationLinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsServer).GetLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.As/GetLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsServer).GetLink(ctx, req.(*GetApplicationLinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _As_SetLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetApplicationLinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsServer).SetLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.As/SetLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsServer).SetLink(ctx, req.(*SetApplicationLinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _As_DeleteLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationIdentifiers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsServer).DeleteLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.As/DeleteLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsServer).DeleteLink(ctx, req.(*ApplicationIdentifiers))
	}
	return interceptor(ctx, in, info, handler)
}

func _As_GetLinkStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationIdentifiers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsServer).GetLinkStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.As/GetLinkStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsServer).GetLinkStats(ctx, req.(*ApplicationIdentifiers))
	}
	return interceptor(ctx, in, info, handler)
}

var _As_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ttn.lorawan.v3.As",
	HandlerType: (*AsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLink",
			Handler:    _As_GetLink_Handler,
		},
		{
			MethodName: "SetLink",
			Handler:    _As_SetLink_Handler,
		},
		{
			MethodName: "DeleteLink",
			Handler:    _As_DeleteLink_Handler,
		},
		{
			MethodName: "GetLinkStats",
			Handler:    _As_GetLinkStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lorawan-stack/api/applicationserver.proto",
}

// NsAsClient is the client API for NsAs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NsAsClient interface {
	HandleUplink(ctx context.Context, in *NsAsHandleUplinkRequest, opts ...grpc.CallOption) (*types.Empty, error)
}

type nsAsClient struct {
	cc *grpc.ClientConn
}

func NewNsAsClient(cc *grpc.ClientConn) NsAsClient {
	return &nsAsClient{cc}
}

func (c *nsAsClient) HandleUplink(ctx context.Context, in *NsAsHandleUplinkRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.NsAs/HandleUplink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NsAsServer is the server API for NsAs service.
type NsAsServer interface {
	HandleUplink(context.Context, *NsAsHandleUplinkRequest) (*types.Empty, error)
}

// UnimplementedNsAsServer can be embedded to have forward compatible implementations.
type UnimplementedNsAsServer struct {
}

func (*UnimplementedNsAsServer) HandleUplink(ctx context.Context, req *NsAsHandleUplinkRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleUplink not implemented")
}

func RegisterNsAsServer(s *grpc.Server, srv NsAsServer) {
	s.RegisterService(&_NsAs_serviceDesc, srv)
}

func _NsAs_HandleUplink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NsAsHandleUplinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsAsServer).HandleUplink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.NsAs/HandleUplink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsAsServer).HandleUplink(ctx, req.(*NsAsHandleUplinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NsAs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ttn.lorawan.v3.NsAs",
	HandlerType: (*NsAsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandleUplink",
			Handler:    _NsAs_HandleUplink_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lorawan-stack/api/applicationserver.proto",
}

// AppAsClient is the client API for AppAs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AppAsClient interface {
	// Subscribe to upstream messages.
	Subscribe(ctx context.Context, in *ApplicationIdentifiers, opts ...grpc.CallOption) (AppAs_SubscribeClient, error)
	// Push downlink messages to the end of the downlink queue.
	DownlinkQueuePush(ctx context.Context, in *DownlinkQueueRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// Replace the entire downlink queue with the specified messages.
	// This can also be used to empty the queue by specifying no messages.
	DownlinkQueueReplace(ctx context.Context, in *DownlinkQueueRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// List the items currently in the downlink queue.
	DownlinkQueueList(ctx context.Context, in *EndDeviceIdentifiers, opts ...grpc.CallOption) (*ApplicationDownlinks, error)
	// Get connection information to connect an MQTT client.
	GetMQTTConnectionInfo(ctx context.Context, in *ApplicationIdentifiers, opts ...grpc.CallOption) (*MQTTConnectionInfo, error)
	// Simulate an upstream message. This can be used to test integrations.
	SimulateUplink(ctx context.Context, in *ApplicationUp, opts ...grpc.CallOption) (*types.Empty, error)
}

type appAsClient struct {
	cc *grpc.ClientConn
}

func NewAppAsClient(cc *grpc.ClientConn) AppAsClient {
	return &appAsClient{cc}
}

func (c *appAsClient) Subscribe(ctx context.Context, in *ApplicationIdentifiers, opts ...grpc.CallOption) (AppAs_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppAs_serviceDesc.Streams[0], "/ttn.lorawan.v3.AppAs/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &appAsSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppAs_SubscribeClient interface {
	Recv() (*ApplicationUp, error)
	grpc.ClientStream
}

type appAsSubscribeClient struct {
	grpc.ClientStream
}

func (x *appAsSubscribeClient) Recv() (*ApplicationUp, error) {
	m := new(ApplicationUp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appAsClient) DownlinkQueuePush(ctx context.Context, in *DownlinkQueueRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.AppAs/DownlinkQueuePush", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appAsClient) DownlinkQueueReplace(ctx context.Context, in *DownlinkQueueRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.AppAs/DownlinkQueueReplace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appAsClient) DownlinkQueueList(ctx context.Context, in *EndDeviceIdentifiers, opts ...grpc.CallOption) (*ApplicationDownlinks, error) {
	out := new(ApplicationDownlinks)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.AppAs/DownlinkQueueList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appAsClient) GetMQTTConnectionInfo(ctx context.Context, in *ApplicationIdentifiers, opts ...grpc.CallOption) (*MQTTConnectionInfo, error) {
	out := new(MQTTConnectionInfo)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.AppAs/GetMQTTConnectionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appAsClient) SimulateUplink(ctx context.Context, in *ApplicationUp, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.AppAs/SimulateUplink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppAsServer is the server API for AppAs service.
type AppAsServer interface {
	// Subscribe to upstream messages.
	Subscribe(*ApplicationIdentifiers, AppAs_SubscribeServer) error
	// Push downlink messages to the end of the downlink queue.
	DownlinkQueuePush(context.Context, *DownlinkQueueRequest) (*types.Empty, error)
	// Replace the entire downlink queue with the specified messages.
	// This can also be used to empty the queue by specifying no messages.
	DownlinkQueueReplace(context.Context, *DownlinkQueueRequest) (*types.Empty, error)
	// List the items currently in the downlink queue.
	DownlinkQueueList(context.Context, *EndDeviceIdentifiers) (*ApplicationDownlinks, error)
	// Get connection information to connect an MQTT client.
	GetMQTTConnectionInfo(context.Context, *ApplicationIdentifiers) (*MQTTConnectionInfo, error)
	// Simulate an upstream message. This can be used to test integrations.
	SimulateUplink(context.Context, *ApplicationUp) (*types.Empty, error)
}

// UnimplementedAppAsServer can be embedded to have forward compatible implementations.
type UnimplementedAppAsServer struct {
}

func (*UnimplementedAppAsServer) Subscribe(req *ApplicationIdentifiers, srv AppAs_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (*UnimplementedAppAsServer) DownlinkQueuePush(ctx context.Context, req *DownlinkQueueRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownlinkQueuePush not implemented")
}
func (*UnimplementedAppAsServer) DownlinkQueueReplace(ctx context.Context, req *DownlinkQueueRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownlinkQueueReplace not implemented")
}
func (*UnimplementedAppAsServer) DownlinkQueueList(ctx context.Context, req *EndDeviceIdentifiers) (*ApplicationDownlinks, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownlinkQueueList not implemented")
}
func (*UnimplementedAppAsServer) GetMQTTConnectionInfo(ctx context.Context, req *ApplicationIdentifiers) (*MQTTConnectionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMQTTConnectionInfo not implemented")
}
func (*UnimplementedAppAsServer) SimulateUplink(ctx context.Context, req *ApplicationUp) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SimulateUplink not implemented")
}

func RegisterAppAsServer(s *grpc.Server, srv AppAsServer) {
	s.RegisterService(&_AppAs_serviceDesc, srv)
}

func _AppAs_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ApplicationIdentifiers)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppAsServer).Subscribe(m, &appAsSubscribeServer{stream})
}

type AppAs_SubscribeServer interface {
	Send(*ApplicationUp) error
	grpc.ServerStream
}

type appAsSubscribeServer struct {
	grpc.ServerStream
}

func (x *appAsSubscribeServer) Send(m *ApplicationUp) error {
	return x.ServerStream.SendMsg(m)
}

func _AppAs_DownlinkQueuePush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownlinkQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppAsServer).DownlinkQueuePush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.AppAs/DownlinkQueuePush",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppAsServer).DownlinkQueuePush(ctx, req.(*DownlinkQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppAs_DownlinkQueueReplace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownlinkQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppAsServer).DownlinkQueueReplace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.AppAs/DownlinkQueueReplace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppAsServer).DownlinkQueueReplace(ctx, req.(*DownlinkQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppAs_DownlinkQueueList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndDeviceIdentifiers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppAsServer).DownlinkQueueList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.AppAs/DownlinkQueueList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppAsServer).DownlinkQueueList(ctx, req.(*EndDeviceIdentifiers))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppAs_GetMQTTConnectionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationIdentifiers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppAsServer).GetMQTTConnectionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.AppAs/GetMQTTConnectionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppAsServer).GetMQTTConnectionInfo(ctx, req.(*ApplicationIdentifiers))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppAs_SimulateUplink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationUp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppAsServer).SimulateUplink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.AppAs/SimulateUplink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppAsServer).SimulateUplink(ctx, req.(*ApplicationUp))
	}
	return interceptor(ctx, in, info, handler)
}

var _AppAs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ttn.lorawan.v3.AppAs",
	HandlerType: (*AppAsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DownlinkQueuePush",
			Handler:    _AppAs_DownlinkQueuePush_Handler,
		},
		{
			MethodName: "DownlinkQueueReplace",
			Handler:    _AppAs_DownlinkQueueReplace_Handler,
		},
		{
			MethodName: "DownlinkQueueList",
			Handler:    _AppAs_DownlinkQueueList_Handler,
		},
		{
			MethodName: "GetMQTTConnectionInfo",
			Handler:    _AppAs_GetMQTTConnectionInfo_Handler,
		},
		{
			MethodName: "SimulateUplink",
			Handler:    _AppAs_SimulateUplink_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _AppAs_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lorawan-stack/api/applicationserver.proto",
}

// AsEndDeviceRegistryClient is the client API for AsEndDeviceRegistry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AsEndDeviceRegistryClient interface {
	// Get returns the device that matches the given identifiers.
	// If there are multiple matches, an error will be returned.
	Get(ctx context.Context, in *GetEndDeviceRequest, opts ...grpc.CallOption) (*EndDevice, error)
	// Set creates or updates the device.
	Set(ctx context.Context, in *SetEndDeviceRequest, opts ...grpc.CallOption) (*EndDevice, error)
	// Delete deletes the device that matches the given identifiers.
	// If there are multiple matches, an error will be returned.
	Delete(ctx context.Context, in *EndDeviceIdentifiers, opts ...grpc.CallOption) (*types.Empty, error)
}

type asEndDeviceRegistryClient struct {
	cc *grpc.ClientConn
}

func NewAsEndDeviceRegistryClient(cc *grpc.ClientConn) AsEndDeviceRegistryClient {
	return &asEndDeviceRegistryClient{cc}
}

func (c *asEndDeviceRegistryClient) Get(ctx context.Context, in *GetEndDeviceRequest, opts ...grpc.CallOption) (*EndDevice, error) {
	out := new(EndDevice)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.AsEndDeviceRegistry/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asEndDeviceRegistryClient) Set(ctx context.Context, in *SetEndDeviceRequest, opts ...grpc.CallOption) (*EndDevice, error) {
	out := new(EndDevice)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.AsEndDeviceRegistry/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asEndDeviceRegistryClient) Delete(ctx context.Context, in *EndDeviceIdentifiers, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.AsEndDeviceRegistry/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AsEndDeviceRegistryServer is the server API for AsEndDeviceRegistry service.
type AsEndDeviceRegistryServer interface {
	// Get returns the device that matches the given identifiers.
	// If there are multiple matches, an error will be returned.
	Get(context.Context, *GetEndDeviceRequest) (*EndDevice, error)
	// Set creates or updates the device.
	Set(context.Context, *SetEndDeviceRequest) (*EndDevice, error)
	// Delete deletes the device that matches the given identifiers.
	// If there are multiple matches, an error will be returned.
	Delete(context.Context, *EndDeviceIdentifiers) (*types.Empty, error)
}

// UnimplementedAsEndDeviceRegistryServer can be embedded to have forward compatible implementations.
type UnimplementedAsEndDeviceRegistryServer struct {
}

func (*UnimplementedAsEndDeviceRegistryServer) Get(ctx context.Context, req *GetEndDeviceRequest) (*EndDevice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedAsEndDeviceRegistryServer) Set(ctx context.Context, req *SetEndDeviceRequest) (*EndDevice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (*UnimplementedAsEndDeviceRegistryServer) Delete(ctx context.Context, req *EndDeviceIdentifiers) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}

func RegisterAsEndDeviceRegistryServer(s *grpc.Server, srv AsEndDeviceRegistryServer) {
	s.RegisterService(&_AsEndDeviceRegistry_serviceDesc, srv)
}

func _AsEndDeviceRegistry_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsEndDeviceRegistryServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.AsEndDeviceRegistry/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsEndDeviceRegistryServer).Get(ctx, req.(*GetEndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsEndDeviceRegistry_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetEndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsEndDeviceRegistryServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.AsEndDeviceRegistry/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsEndDeviceRegistryServer).Set(ctx, req.(*SetEndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsEndDeviceRegistry_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndDeviceIdentifiers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsEndDeviceRegistryServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.AsEndDeviceRegistry/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsEndDeviceRegistryServer).Delete(ctx, req.(*EndDeviceIdentifiers))
	}
	return interceptor(ctx, in, info, handler)
}

var _AsEndDeviceRegistry_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ttn.lorawan.v3.AsEndDeviceRegistry",
	HandlerType: (*AsEndDeviceRegistryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _AsEndDeviceRegistry_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _AsEndDeviceRegistry_Set_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _AsEndDeviceRegistry_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lorawan-stack/api/applicationserver.proto",
}

func (m *ApplicationLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationLink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplicationLink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkipPayloadCrypto != nil {
		{
			size, err := m.SkipPayloadCrypto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApplicationserver(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TLS {
		i--
		if m.TLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.DefaultFormatters != nil {
		{
			size, err := m.DefaultFormatters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApplicationserver(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.APIKey) > 0 {
		i -= len(m.APIKey)
		copy(dAtA[i:], m.APIKey)
		i = encodeVarintApplicationserver(dAtA, i, uint64(len(m.APIKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NetworkServerAddress) > 0 {
		i -= len(m.NetworkServerAddress)
		copy(dAtA[i:], m.NetworkServerAddress)
		i = encodeVarintApplicationserver(dAtA, i, uint64(len(m.NetworkServerAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetApplicationLinkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetApplicationLinkRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetApplicationLinkRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FieldMask.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApplicationserver(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ApplicationIdentifiers.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApplicationserver(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SetApplicationLinkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetApplicationLinkRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetApplicationLinkRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FieldMask.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApplicationserver(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.ApplicationLink.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApplicationserver(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ApplicationIdentifiers.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApplicationserver(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ApplicationLinkStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationLinkStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplicationLinkStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DownlinkCount != 0 {
		i = encodeVarintApplicationserver(dAtA, i, m.DownlinkCount)
		i--
		dAtA[i] = 0x30
	}
	if m.LastDownlinkForwardedAt != nil {
		n8, err8 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.LastDownlinkForwardedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastDownlinkForwardedAt):])
		if err8 != nil {
			return 0, err8
		}
		i -= n8
		i = encodeVarintApplicationserver(dAtA, i, uint64(n8))
		i--
		dAtA[i] = 0x2a
	}
	if m.UpCount != 0 {
		i = encodeVarintApplicationserver(dAtA, i, m.UpCount)
		i--
		dAtA[i] = 0x20
	}
	if m.LastUpReceivedAt != nil {
		n9, err9 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.LastUpReceivedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastUpReceivedAt):])
		if err9 != nil {
			return 0, err9
		}
		i -= n9
		i = encodeVarintApplicationserver(dAtA, i, uint64(n9))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NetworkServerAddress) > 0 {
		i -= len(m.NetworkServerAddress)
		copy(dAtA[i:], m.NetworkServerAddress)
		i = encodeVarintApplicationserver(dAtA, i, uint64(len(m.NetworkServerAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.LinkedAt != nil {
		n10, err10 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.LinkedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.LinkedAt):])
		if err10 != nil {
			return 0, err10
		}
		i -= n10
		i = encodeVarintApplicationserver(dAtA, i, uint64(n10))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NsAsHandleUplinkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NsAsHandleUplinkRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NsAsHandleUplinkRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApplicationUps) > 0 {
		for iNdEx := len(m.ApplicationUps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ApplicationUps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApplicationserver(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintApplicationserver(dAtA []byte, offset int, v uint64) int {
	offset -= sovApplicationserver(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedApplicationLink(r randyApplicationserver, easy bool) *ApplicationLink {
	this := &ApplicationLink{}
	this.NetworkServerAddress = randStringApplicationserver(r)
	this.APIKey = randStringApplicationserver(r)
	if r.Intn(5) != 0 {
		this.DefaultFormatters = NewPopulatedMessagePayloadFormatters(r, easy)
	}
	this.TLS = bool(r.Intn(2) == 0)
	if r.Intn(5) != 0 {
		this.SkipPayloadCrypto = types.NewPopulatedBoolValue(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetApplicationLinkRequest(r randyApplicationserver, easy bool) *GetApplicationLinkRequest {
	this := &GetApplicationLinkRequest{}
	v1 := NewPopulatedApplicationIdentifiers(r, easy)
	this.ApplicationIdentifiers = *v1
	v2 := types.NewPopulatedFieldMask(r, easy)
	this.FieldMask = *v2
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSetApplicationLinkRequest(r randyApplicationserver, easy bool) *SetApplicationLinkRequest {
	this := &SetApplicationLinkRequest{}
	v3 := NewPopulatedApplicationIdentifiers(r, easy)
	this.ApplicationIdentifiers = *v3
	v4 := NewPopulatedApplicationLink(r, easy)
	this.ApplicationLink = *v4
	v5 := types.NewPopulatedFieldMask(r, easy)
	this.FieldMask = *v5
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedApplicationLinkStats(r randyApplicationserver, easy bool) *ApplicationLinkStats {
	this := &ApplicationLinkStats{}
	if r.Intn(5) != 0 {
		this.LinkedAt = github_com_gogo_protobuf_types.NewPopulatedStdTime(r, easy)
	}
	this.NetworkServerAddress = randStringApplicationserver(r)
	if r.Intn(5) != 0 {
		this.LastUpReceivedAt = github_com_gogo_protobuf_types.NewPopulatedStdTime(r, easy)
	}
	this.UpCount = uint64(r.Uint32())
	if r.Intn(5) != 0 {
		this.LastDownlinkForwardedAt = github_com_gogo_protobuf_types.NewPopulatedStdTime(r, easy)
	}
	this.DownlinkCount = uint64(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNsAsHandleUplinkRequest(r randyApplicationserver, easy bool) *NsAsHandleUplinkRequest {
	this := &NsAsHandleUplinkRequest{}
	if r.Intn(5) == 0 {
		v6 := r.Intn(5)
		this.ApplicationUps = make([]*ApplicationUp, v6)
		for i := 0; i < v6; i++ {
			this.ApplicationUps[i] = NewPopulatedApplicationUp(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyApplicationserver interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneApplicationserver(r randyApplicationserver) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringApplicationserver(r randyApplicationserver) string {
	v7 := r.Intn(100)
	tmps := make([]rune, v7)
	for i := 0; i < v7; i++ {
		tmps[i] = randUTF8RuneApplicationserver(r)
	}
	return string(tmps)
}
func randUnrecognizedApplicationserver(r randyApplicationserver, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldApplicationserver(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldApplicationserver(dAtA []byte, r randyApplicationserver, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateApplicationserver(dAtA, uint64(key))
		v8 := r.Int63()
		if r.Intn(2) == 0 {
			v8 *= -1
		}
		dAtA = encodeVarintPopulateApplicationserver(dAtA, uint64(v8))
	case 1:
		dAtA = encodeVarintPopulateApplicationserver(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateApplicationserver(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateApplicationserver(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateApplicationserver(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateApplicationserver(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(v&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *ApplicationLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NetworkServerAddress)
	if l > 0 {
		n += 1 + l + sovApplicationserver(uint64(l))
	}
	l = len(m.APIKey)
	if l > 0 {
		n += 1 + l + sovApplicationserver(uint64(l))
	}
	if m.DefaultFormatters != nil {
		l = m.DefaultFormatters.Size()
		n += 1 + l + sovApplicationserver(uint64(l))
	}
	if m.TLS {
		n += 2
	}
	if m.SkipPayloadCrypto != nil {
		l = m.SkipPayloadCrypto.Size()
		n += 1 + l + sovApplicationserver(uint64(l))
	}
	return n
}

func (m *GetApplicationLinkRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ApplicationIdentifiers.Size()
	n += 1 + l + sovApplicationserver(uint64(l))
	l = m.FieldMask.Size()
	n += 1 + l + sovApplicationserver(uint64(l))
	return n
}

func (m *SetApplicationLinkRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ApplicationIdentifiers.Size()
	n += 1 + l + sovApplicationserver(uint64(l))
	l = m.ApplicationLink.Size()
	n += 1 + l + sovApplicationserver(uint64(l))
	l = m.FieldMask.Size()
	n += 1 + l + sovApplicationserver(uint64(l))
	return n
}

func (m *ApplicationLinkStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LinkedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.LinkedAt)
		n += 1 + l + sovApplicationserver(uint64(l))
	}
	l = len(m.NetworkServerAddress)
	if l > 0 {
		n += 1 + l + sovApplicationserver(uint64(l))
	}
	if m.LastUpReceivedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastUpReceivedAt)
		n += 1 + l + sovApplicationserver(uint64(l))
	}
	if m.UpCount != 0 {
		n += 1 + sovApplicationserver(m.UpCount)
	}
	if m.LastDownlinkForwardedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastDownlinkForwardedAt)
		n += 1 + l + sovApplicationserver(uint64(l))
	}
	if m.DownlinkCount != 0 {
		n += 1 + sovApplicationserver(m.DownlinkCount)
	}
	return n
}

func (m *NsAsHandleUplinkRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApplicationUps) > 0 {
		for _, e := range m.ApplicationUps {
			l = e.Size()
			n += 1 + l + sovApplicationserver(uint64(l))
		}
	}
	return n
}

func sovApplicationserver(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApplicationserver(x uint64) (n int) {
	return sovApplicationserver((x << 1) ^ uint64((int64(x) >> 63)))
}
func (this *ApplicationLink) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApplicationLink{`,
		`NetworkServerAddress:` + fmt.Sprintf("%v", this.NetworkServerAddress) + `,`,
		`APIKey:` + fmt.Sprintf("%v", this.APIKey) + `,`,
		`DefaultFormatters:` + strings.Replace(fmt.Sprintf("%v", this.DefaultFormatters), "MessagePayloadFormatters", "MessagePayloadFormatters", 1) + `,`,
		`TLS:` + fmt.Sprintf("%v", this.TLS) + `,`,
		`SkipPayloadCrypto:` + strings.Replace(fmt.Sprintf("%v", this.SkipPayloadCrypto), "BoolValue", "types.BoolValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetApplicationLinkRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetApplicationLinkRequest{`,
		`ApplicationIdentifiers:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ApplicationIdentifiers), "ApplicationIdentifiers", "ApplicationIdentifiers", 1), `&`, ``, 1) + `,`,
		`FieldMask:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.FieldMask), "FieldMask", "types.FieldMask", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SetApplicationLinkRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SetApplicationLinkRequest{`,
		`ApplicationIdentifiers:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ApplicationIdentifiers), "ApplicationIdentifiers", "ApplicationIdentifiers", 1), `&`, ``, 1) + `,`,
		`ApplicationLink:` + strings.Replace(strings.Replace(this.ApplicationLink.String(), "ApplicationLink", "ApplicationLink", 1), `&`, ``, 1) + `,`,
		`FieldMask:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.FieldMask), "FieldMask", "types.FieldMask", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApplicationLinkStats) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApplicationLinkStats{`,
		`LinkedAt:` + strings.Replace(fmt.Sprintf("%v", this.LinkedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`NetworkServerAddress:` + fmt.Sprintf("%v", this.NetworkServerAddress) + `,`,
		`LastUpReceivedAt:` + strings.Replace(fmt.Sprintf("%v", this.LastUpReceivedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`UpCount:` + fmt.Sprintf("%v", this.UpCount) + `,`,
		`LastDownlinkForwardedAt:` + strings.Replace(fmt.Sprintf("%v", this.LastDownlinkForwardedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`DownlinkCount:` + fmt.Sprintf("%v", this.DownlinkCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NsAsHandleUplinkRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForApplicationUps := "[]*ApplicationUp{"
	for _, f := range this.ApplicationUps {
		repeatedStringForApplicationUps += strings.Replace(fmt.Sprintf("%v", f), "ApplicationUp", "ApplicationUp", 1) + ","
	}
	repeatedStringForApplicationUps += "}"
	s := strings.Join([]string{`&NsAsHandleUplinkRequest{`,
		`ApplicationUps:` + repeatedStringForApplicationUps + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringApplicationserver(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ApplicationLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApplicationserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkServerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApplicationserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkServerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field APIKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApplicationserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.APIKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFormatters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultFormatters == nil {
				m.DefaultFormatters = &MessagePayloadFormatters{}
			}
			if err := m.DefaultFormatters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TLS = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipPayloadCrypto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkipPayloadCrypto == nil {
				m.SkipPayloadCrypto = &types.BoolValue{}
			}
			if err := m.SkipPayloadCrypto.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApplicationserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetApplicationLinkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApplicationserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetApplicationLinkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetApplicationLinkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationIdentifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ApplicationIdentifiers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FieldMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApplicationserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetApplicationLinkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApplicationserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetApplicationLinkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetApplicationLinkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationIdentifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ApplicationIdentifiers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationLink", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ApplicationLink.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FieldMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApplicationserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplicationLinkStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApplicationserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationLinkStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationLinkStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LinkedAt == nil {
				m.LinkedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.LinkedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkServerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApplicationserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkServerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpReceivedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpReceivedAt == nil {
				m.LastUpReceivedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.LastUpReceivedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpCount", wireType)
			}
			m.UpCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDownlinkForwardedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastDownlinkForwardedAt == nil {
				m.LastDownlinkForwardedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.LastDownlinkForwardedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownlinkCount", wireType)
			}
			m.DownlinkCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownlinkCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApplicationserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NsAsHandleUplinkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApplicationserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NsAsHandleUplinkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NsAsHandleUplinkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationUps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserver
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationUps = append(m.ApplicationUps, &ApplicationUp{})
			if err := m.ApplicationUps[len(m.ApplicationUps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApplicationserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApplicationserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApplicationserver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApplicationserver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApplicationserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApplicationserver
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApplicationserver
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApplicationserver
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApplicationserver        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApplicationserver          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApplicationserver = fmt.Errorf("proto: unexpected end of group")
)
