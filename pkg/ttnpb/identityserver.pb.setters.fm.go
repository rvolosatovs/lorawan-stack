// Code generated by protoc-gen-fieldmask. DO NOT EDIT.

package ttnpb

import fmt "fmt"

func (dst *AuthInfoResponse) SetFields(src *AuthInfoResponse, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "universal_rights":
			if len(subs) > 0 {
				var newDst, newSrc *Rights
				if (src == nil || src.UniversalRights == nil) && dst.UniversalRights == nil {
					continue
				}
				if src != nil {
					newSrc = src.UniversalRights
				}
				if dst.UniversalRights != nil {
					newDst = dst.UniversalRights
				} else {
					newDst = &Rights{}
					dst.UniversalRights = newDst
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.UniversalRights = src.UniversalRights
				} else {
					dst.UniversalRights = nil
				}
			}
		case "is_admin":
			if len(subs) > 0 {
				return fmt.Errorf("'is_admin' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.IsAdmin = src.IsAdmin
			} else {
				var zero bool
				dst.IsAdmin = zero
			}

		case "access_method":
			if len(subs) == 0 && src == nil {
				dst.AccessMethod = nil
				continue
			} else if len(subs) == 0 {
				dst.AccessMethod = src.AccessMethod
				continue
			}

			subPathMap := _processPaths(subs)
			if len(subPathMap) > 1 {
				return fmt.Errorf("more than one field specified for oneof field '%s'", name)
			}
			for oneofName, oneofSubs := range subPathMap {
				switch oneofName {
				case "api_key":
					_, srcOk := src.AccessMethod.(*AuthInfoResponse_APIKey)
					if !srcOk && src.AccessMethod != nil {
						return fmt.Errorf("attempt to set oneof 'api_key', while different oneof is set in source")
					}
					_, dstOk := dst.AccessMethod.(*AuthInfoResponse_APIKey)
					if !dstOk && dst.AccessMethod != nil {
						return fmt.Errorf("attempt to set oneof 'api_key', while different oneof is set in destination")
					}
					if len(oneofSubs) > 0 {
						var newDst, newSrc *AuthInfoResponse_APIKeyAccess
						if !srcOk && !dstOk {
							continue
						}
						if srcOk {
							newSrc = src.AccessMethod.(*AuthInfoResponse_APIKey).APIKey
						}
						if dstOk {
							newDst = dst.AccessMethod.(*AuthInfoResponse_APIKey).APIKey
						} else {
							newDst = &AuthInfoResponse_APIKeyAccess{}
							dst.AccessMethod = &AuthInfoResponse_APIKey{APIKey: newDst}
						}
						if err := newDst.SetFields(newSrc, oneofSubs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.AccessMethod = src.AccessMethod
						} else {
							dst.AccessMethod = nil
						}
					}
				case "oauth_access_token":
					_, srcOk := src.AccessMethod.(*AuthInfoResponse_OAuthAccessToken)
					if !srcOk && src.AccessMethod != nil {
						return fmt.Errorf("attempt to set oneof 'oauth_access_token', while different oneof is set in source")
					}
					_, dstOk := dst.AccessMethod.(*AuthInfoResponse_OAuthAccessToken)
					if !dstOk && dst.AccessMethod != nil {
						return fmt.Errorf("attempt to set oneof 'oauth_access_token', while different oneof is set in destination")
					}
					if len(oneofSubs) > 0 {
						var newDst, newSrc *OAuthAccessToken
						if !srcOk && !dstOk {
							continue
						}
						if srcOk {
							newSrc = src.AccessMethod.(*AuthInfoResponse_OAuthAccessToken).OAuthAccessToken
						}
						if dstOk {
							newDst = dst.AccessMethod.(*AuthInfoResponse_OAuthAccessToken).OAuthAccessToken
						} else {
							newDst = &OAuthAccessToken{}
							dst.AccessMethod = &AuthInfoResponse_OAuthAccessToken{OAuthAccessToken: newDst}
						}
						if err := newDst.SetFields(newSrc, oneofSubs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.AccessMethod = src.AccessMethod
						} else {
							dst.AccessMethod = nil
						}
					}
				case "user_session":
					_, srcOk := src.AccessMethod.(*AuthInfoResponse_UserSession)
					if !srcOk && src.AccessMethod != nil {
						return fmt.Errorf("attempt to set oneof 'user_session', while different oneof is set in source")
					}
					_, dstOk := dst.AccessMethod.(*AuthInfoResponse_UserSession)
					if !dstOk && dst.AccessMethod != nil {
						return fmt.Errorf("attempt to set oneof 'user_session', while different oneof is set in destination")
					}
					if len(oneofSubs) > 0 {
						var newDst, newSrc *UserSession
						if !srcOk && !dstOk {
							continue
						}
						if srcOk {
							newSrc = src.AccessMethod.(*AuthInfoResponse_UserSession).UserSession
						}
						if dstOk {
							newDst = dst.AccessMethod.(*AuthInfoResponse_UserSession).UserSession
						} else {
							newDst = &UserSession{}
							dst.AccessMethod = &AuthInfoResponse_UserSession{UserSession: newDst}
						}
						if err := newDst.SetFields(newSrc, oneofSubs...); err != nil {
							return err
						}
					} else {
						if src != nil {
							dst.AccessMethod = src.AccessMethod
						} else {
							dst.AccessMethod = nil
						}
					}

				default:
					return fmt.Errorf("invalid oneof field: '%s.%s'", name, oneofName)
				}
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *AuthInfoResponse_APIKeyAccess) SetFields(src *AuthInfoResponse_APIKeyAccess, paths ...string) error {
	for name, subs := range _processPaths(paths) {
		switch name {
		case "api_key":
			if len(subs) > 0 {
				var newDst, newSrc *APIKey
				if src != nil {
					newSrc = &src.APIKey
				}
				newDst = &dst.APIKey
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.APIKey = src.APIKey
				} else {
					var zero APIKey
					dst.APIKey = zero
				}
			}
		case "entity_ids":
			if len(subs) > 0 {
				var newDst, newSrc *EntityIdentifiers
				if src != nil {
					newSrc = &src.EntityIDs
				}
				newDst = &dst.EntityIDs
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.EntityIDs = src.EntityIDs
				} else {
					var zero EntityIdentifiers
					dst.EntityIDs = zero
				}
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}
