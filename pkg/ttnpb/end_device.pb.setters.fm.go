// Code generated by protoc-gen-fieldmask. DO NOT EDIT.

package ttnpb

import (
	fmt "fmt"
	time "time"

	types "github.com/gogo/protobuf/types"
	go_thethings_network_lorawan_stack_pkg_types "go.thethings.network/lorawan-stack/pkg/types"
)

func (dst *Session) SetFields(src *Session, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "dev_addr":
			if len(subs) > 0 {
				return fmt.Errorf("'dev_addr' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.DevAddr = src.DevAddr
			} else {
				var zero go_thethings_network_lorawan_stack_pkg_types.DevAddr
				dst.DevAddr = zero
			}
		case "keys":
			if len(subs) > 0 {
				newDst := &dst.SessionKeys
				var newSrc *SessionKeys
				if src != nil {
					newSrc = &src.SessionKeys
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.SessionKeys = src.SessionKeys
				} else {
					var zero SessionKeys
					dst.SessionKeys = zero
				}
			}
		case "last_f_cnt_up":
			if len(subs) > 0 {
				return fmt.Errorf("'last_f_cnt_up' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LastFCntUp = src.LastFCntUp
			} else {
				var zero uint32
				dst.LastFCntUp = zero
			}
		case "last_n_f_cnt_down":
			if len(subs) > 0 {
				return fmt.Errorf("'last_n_f_cnt_down' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LastNFCntDown = src.LastNFCntDown
			} else {
				var zero uint32
				dst.LastNFCntDown = zero
			}
		case "last_a_f_cnt_down":
			if len(subs) > 0 {
				return fmt.Errorf("'last_a_f_cnt_down' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LastAFCntDown = src.LastAFCntDown
			} else {
				var zero uint32
				dst.LastAFCntDown = zero
			}
		case "last_conf_f_cnt_down":
			if len(subs) > 0 {
				return fmt.Errorf("'last_conf_f_cnt_down' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LastConfFCntDown = src.LastConfFCntDown
			} else {
				var zero uint32
				dst.LastConfFCntDown = zero
			}
		case "started_at":
			if len(subs) > 0 {
				return fmt.Errorf("'started_at' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.StartedAt = src.StartedAt
			} else {
				var zero time.Time
				dst.StartedAt = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *MACParameters) SetFields(src *MACParameters, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "max_eirp":
			if len(subs) > 0 {
				return fmt.Errorf("'max_eirp' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MaxEIRP = src.MaxEIRP
			} else {
				var zero float32
				dst.MaxEIRP = zero
			}
		case "uplink_dwell_time":
			if len(subs) > 0 {
				return fmt.Errorf("'uplink_dwell_time' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.UplinkDwellTime = src.UplinkDwellTime
			} else {
				var zero bool
				dst.UplinkDwellTime = zero
			}
		case "downlink_dwell_time":
			if len(subs) > 0 {
				return fmt.Errorf("'downlink_dwell_time' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.DownlinkDwellTime = src.DownlinkDwellTime
			} else {
				var zero bool
				dst.DownlinkDwellTime = zero
			}
		case "adr_data_rate_index":
			if len(subs) > 0 {
				return fmt.Errorf("'adr_data_rate_index' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ADRDataRateIndex = src.ADRDataRateIndex
			} else {
				var zero DataRateIndex
				dst.ADRDataRateIndex = zero
			}
		case "adr_tx_power_index":
			if len(subs) > 0 {
				return fmt.Errorf("'adr_tx_power_index' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ADRTxPowerIndex = src.ADRTxPowerIndex
			} else {
				var zero uint32
				dst.ADRTxPowerIndex = zero
			}
		case "adr_nb_trans":
			if len(subs) > 0 {
				return fmt.Errorf("'adr_nb_trans' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ADRNbTrans = src.ADRNbTrans
			} else {
				var zero uint32
				dst.ADRNbTrans = zero
			}
		case "adr_ack_limit":
			if len(subs) > 0 {
				return fmt.Errorf("'adr_ack_limit' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ADRAckLimit = src.ADRAckLimit
			} else {
				var zero uint32
				dst.ADRAckLimit = zero
			}
		case "adr_ack_delay":
			if len(subs) > 0 {
				return fmt.Errorf("'adr_ack_delay' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ADRAckDelay = src.ADRAckDelay
			} else {
				var zero uint32
				dst.ADRAckDelay = zero
			}
		case "rx1_delay":
			if len(subs) > 0 {
				return fmt.Errorf("'rx1_delay' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Rx1Delay = src.Rx1Delay
			} else {
				var zero RxDelay
				dst.Rx1Delay = zero
			}
		case "rx1_data_rate_offset":
			if len(subs) > 0 {
				return fmt.Errorf("'rx1_data_rate_offset' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Rx1DataRateOffset = src.Rx1DataRateOffset
			} else {
				var zero uint32
				dst.Rx1DataRateOffset = zero
			}
		case "rx2_data_rate_index":
			if len(subs) > 0 {
				return fmt.Errorf("'rx2_data_rate_index' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Rx2DataRateIndex = src.Rx2DataRateIndex
			} else {
				var zero DataRateIndex
				dst.Rx2DataRateIndex = zero
			}
		case "rx2_frequency":
			if len(subs) > 0 {
				return fmt.Errorf("'rx2_frequency' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Rx2Frequency = src.Rx2Frequency
			} else {
				var zero uint64
				dst.Rx2Frequency = zero
			}
		case "max_duty_cycle":
			if len(subs) > 0 {
				return fmt.Errorf("'max_duty_cycle' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MaxDutyCycle = src.MaxDutyCycle
			} else {
				var zero AggregatedDutyCycle
				dst.MaxDutyCycle = zero
			}
		case "rejoin_time_periodicity":
			if len(subs) > 0 {
				return fmt.Errorf("'rejoin_time_periodicity' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.RejoinTimePeriodicity = src.RejoinTimePeriodicity
			} else {
				var zero RejoinTimeExponent
				dst.RejoinTimePeriodicity = zero
			}
		case "rejoin_count_periodicity":
			if len(subs) > 0 {
				return fmt.Errorf("'rejoin_count_periodicity' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.RejoinCountPeriodicity = src.RejoinCountPeriodicity
			} else {
				var zero RejoinCountExponent
				dst.RejoinCountPeriodicity = zero
			}
		case "ping_slot_frequency":
			if len(subs) > 0 {
				return fmt.Errorf("'ping_slot_frequency' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.PingSlotFrequency = src.PingSlotFrequency
			} else {
				var zero uint64
				dst.PingSlotFrequency = zero
			}
		case "ping_slot_data_rate_index":
			if len(subs) > 0 {
				return fmt.Errorf("'ping_slot_data_rate_index' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.PingSlotDataRateIndex = src.PingSlotDataRateIndex
			} else {
				var zero DataRateIndex
				dst.PingSlotDataRateIndex = zero
			}
		case "beacon_frequency":
			if len(subs) > 0 {
				return fmt.Errorf("'beacon_frequency' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.BeaconFrequency = src.BeaconFrequency
			} else {
				var zero uint64
				dst.BeaconFrequency = zero
			}
		case "channels":
			if len(subs) > 0 {
				return fmt.Errorf("'channels' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Channels = src.Channels
			} else {
				dst.Channels = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *EndDeviceBrand) SetFields(src *EndDeviceBrand, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "id":
			if len(subs) > 0 {
				return fmt.Errorf("'id' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ID = src.ID
			} else {
				var zero string
				dst.ID = zero
			}
		case "name":
			if len(subs) > 0 {
				return fmt.Errorf("'name' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Name = src.Name
			} else {
				var zero string
				dst.Name = zero
			}
		case "url":
			if len(subs) > 0 {
				return fmt.Errorf("'url' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.URL = src.URL
			} else {
				var zero string
				dst.URL = zero
			}
		case "logos":
			if len(subs) > 0 {
				return fmt.Errorf("'logos' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Logos = src.Logos
			} else {
				dst.Logos = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *EndDeviceModel) SetFields(src *EndDeviceModel, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "brand_id":
			if len(subs) > 0 {
				return fmt.Errorf("'brand_id' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.BrandID = src.BrandID
			} else {
				var zero string
				dst.BrandID = zero
			}
		case "id":
			if len(subs) > 0 {
				return fmt.Errorf("'id' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ID = src.ID
			} else {
				var zero string
				dst.ID = zero
			}
		case "name":
			if len(subs) > 0 {
				return fmt.Errorf("'name' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Name = src.Name
			} else {
				var zero string
				dst.Name = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *EndDeviceVersionIdentifiers) SetFields(src *EndDeviceVersionIdentifiers, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "brand_id":
			if len(subs) > 0 {
				return fmt.Errorf("'brand_id' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.BrandID = src.BrandID
			} else {
				var zero string
				dst.BrandID = zero
			}
		case "model_id":
			if len(subs) > 0 {
				return fmt.Errorf("'model_id' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ModelID = src.ModelID
			} else {
				var zero string
				dst.ModelID = zero
			}
		case "hardware_version":
			if len(subs) > 0 {
				return fmt.Errorf("'hardware_version' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.HardwareVersion = src.HardwareVersion
			} else {
				var zero string
				dst.HardwareVersion = zero
			}
		case "firmware_version":
			if len(subs) > 0 {
				return fmt.Errorf("'firmware_version' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.FirmwareVersion = src.FirmwareVersion
			} else {
				var zero string
				dst.FirmwareVersion = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *EndDeviceVersion) SetFields(src *EndDeviceVersion, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "ids":
			if len(subs) > 0 {
				newDst := &dst.EndDeviceVersionIdentifiers
				var newSrc *EndDeviceVersionIdentifiers
				if src != nil {
					newSrc = &src.EndDeviceVersionIdentifiers
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.EndDeviceVersionIdentifiers = src.EndDeviceVersionIdentifiers
				} else {
					var zero EndDeviceVersionIdentifiers
					dst.EndDeviceVersionIdentifiers = zero
				}
			}
		case "lorawan_version":
			if len(subs) > 0 {
				return fmt.Errorf("'lorawan_version' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LoRaWANVersion = src.LoRaWANVersion
			} else {
				var zero MACVersion
				dst.LoRaWANVersion = zero
			}
		case "lorawan_phy_version":
			if len(subs) > 0 {
				return fmt.Errorf("'lorawan_phy_version' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LoRaWANPHYVersion = src.LoRaWANPHYVersion
			} else {
				var zero PHYVersion
				dst.LoRaWANPHYVersion = zero
			}
		case "frequency_plan_id":
			if len(subs) > 0 {
				return fmt.Errorf("'frequency_plan_id' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.FrequencyPlanID = src.FrequencyPlanID
			} else {
				var zero string
				dst.FrequencyPlanID = zero
			}
		case "photos":
			if len(subs) > 0 {
				return fmt.Errorf("'photos' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Photos = src.Photos
			} else {
				dst.Photos = nil
			}
		case "supports_class_b":
			if len(subs) > 0 {
				return fmt.Errorf("'supports_class_b' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.SupportsClassB = src.SupportsClassB
			} else {
				var zero bool
				dst.SupportsClassB = zero
			}
		case "supports_class_c":
			if len(subs) > 0 {
				return fmt.Errorf("'supports_class_c' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.SupportsClassC = src.SupportsClassC
			} else {
				var zero bool
				dst.SupportsClassC = zero
			}
		case "default_mac_settings":
			if len(subs) > 0 {
				newDst := dst.DefaultMACSettings
				if newDst == nil {
					newDst = &MACSettings{}
					dst.DefaultMACSettings = newDst
				}
				var newSrc *MACSettings
				if src != nil {
					newSrc = src.DefaultMACSettings
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.DefaultMACSettings = src.DefaultMACSettings
				} else {
					dst.DefaultMACSettings = nil
				}
			}
		case "min_frequency":
			if len(subs) > 0 {
				return fmt.Errorf("'min_frequency' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MinFrequency = src.MinFrequency
			} else {
				var zero uint64
				dst.MinFrequency = zero
			}
		case "max_frequency":
			if len(subs) > 0 {
				return fmt.Errorf("'max_frequency' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MaxFrequency = src.MaxFrequency
			} else {
				var zero uint64
				dst.MaxFrequency = zero
			}
		case "supports_join":
			if len(subs) > 0 {
				return fmt.Errorf("'supports_join' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.SupportsJoin = src.SupportsJoin
			} else {
				var zero bool
				dst.SupportsJoin = zero
			}
		case "resets_join_nonces":
			if len(subs) > 0 {
				return fmt.Errorf("'resets_join_nonces' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ResetsJoinNonces = src.ResetsJoinNonces
			} else {
				var zero bool
				dst.ResetsJoinNonces = zero
			}
		case "default_formatters":
			if len(subs) > 0 {
				newDst := &dst.DefaultFormatters
				var newSrc *MessagePayloadFormatters
				if src != nil {
					newSrc = &src.DefaultFormatters
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.DefaultFormatters = src.DefaultFormatters
				} else {
					var zero MessagePayloadFormatters
					dst.DefaultFormatters = zero
				}
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *MACSettings) SetFields(src *MACSettings, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "class_b_timeout":
			if len(subs) > 0 {
				return fmt.Errorf("'class_b_timeout' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ClassBTimeout = src.ClassBTimeout
			} else {
				dst.ClassBTimeout = nil
			}
		case "ping_slot_periodicity":
			if len(subs) > 0 {
				newDst := dst.PingSlotPeriodicity
				if newDst == nil {
					newDst = &MACSettings_PingSlotPeriodValue{}
					dst.PingSlotPeriodicity = newDst
				}
				var newSrc *MACSettings_PingSlotPeriodValue
				if src != nil {
					newSrc = src.PingSlotPeriodicity
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.PingSlotPeriodicity = src.PingSlotPeriodicity
				} else {
					dst.PingSlotPeriodicity = nil
				}
			}
		case "ping_slot_data_rate_index":
			if len(subs) > 0 {
				newDst := dst.PingSlotDataRateIndex
				if newDst == nil {
					newDst = &MACSettings_DataRateIndexValue{}
					dst.PingSlotDataRateIndex = newDst
				}
				var newSrc *MACSettings_DataRateIndexValue
				if src != nil {
					newSrc = src.PingSlotDataRateIndex
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.PingSlotDataRateIndex = src.PingSlotDataRateIndex
				} else {
					dst.PingSlotDataRateIndex = nil
				}
			}
		case "ping_slot_frequency":
			if len(subs) > 0 {
				return fmt.Errorf("'ping_slot_frequency' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.PingSlotFrequency = src.PingSlotFrequency
			} else {
				dst.PingSlotFrequency = nil
			}
		case "class_c_timeout":
			if len(subs) > 0 {
				return fmt.Errorf("'class_c_timeout' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ClassCTimeout = src.ClassCTimeout
			} else {
				dst.ClassCTimeout = nil
			}
		case "rx1_delay":
			if len(subs) > 0 {
				newDst := dst.Rx1Delay
				if newDst == nil {
					newDst = &MACSettings_RxDelayValue{}
					dst.Rx1Delay = newDst
				}
				var newSrc *MACSettings_RxDelayValue
				if src != nil {
					newSrc = src.Rx1Delay
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.Rx1Delay = src.Rx1Delay
				} else {
					dst.Rx1Delay = nil
				}
			}
		case "rx1_data_rate_offset":
			if len(subs) > 0 {
				return fmt.Errorf("'rx1_data_rate_offset' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Rx1DataRateOffset = src.Rx1DataRateOffset
			} else {
				dst.Rx1DataRateOffset = nil
			}
		case "rx2_data_rate_index":
			if len(subs) > 0 {
				newDst := dst.Rx2DataRateIndex
				if newDst == nil {
					newDst = &MACSettings_DataRateIndexValue{}
					dst.Rx2DataRateIndex = newDst
				}
				var newSrc *MACSettings_DataRateIndexValue
				if src != nil {
					newSrc = src.Rx2DataRateIndex
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.Rx2DataRateIndex = src.Rx2DataRateIndex
				} else {
					dst.Rx2DataRateIndex = nil
				}
			}
		case "rx2_frequency":
			if len(subs) > 0 {
				return fmt.Errorf("'rx2_frequency' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Rx2Frequency = src.Rx2Frequency
			} else {
				dst.Rx2Frequency = nil
			}
		case "factory_preset_frequencies":
			if len(subs) > 0 {
				return fmt.Errorf("'factory_preset_frequencies' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.FactoryPresetFrequencies = src.FactoryPresetFrequencies
			} else {
				dst.FactoryPresetFrequencies = nil
			}
		case "max_duty_cycle":
			if len(subs) > 0 {
				newDst := dst.MaxDutyCycle
				if newDst == nil {
					newDst = &MACSettings_AggregatedDutyCycleValue{}
					dst.MaxDutyCycle = newDst
				}
				var newSrc *MACSettings_AggregatedDutyCycleValue
				if src != nil {
					newSrc = src.MaxDutyCycle
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.MaxDutyCycle = src.MaxDutyCycle
				} else {
					dst.MaxDutyCycle = nil
				}
			}
		case "supports_32_bit_f_cnt":
			if len(subs) > 0 {
				return fmt.Errorf("'supports_32_bit_f_cnt' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Supports32BitFCnt = src.Supports32BitFCnt
			} else {
				dst.Supports32BitFCnt = nil
			}
		case "use_adr":
			if len(subs) > 0 {
				return fmt.Errorf("'use_adr' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.UseADR = src.UseADR
			} else {
				dst.UseADR = nil
			}
		case "adr_margin":
			if len(subs) > 0 {
				return fmt.Errorf("'adr_margin' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ADRMargin = src.ADRMargin
			} else {
				dst.ADRMargin = nil
			}
		case "resets_f_cnt":
			if len(subs) > 0 {
				return fmt.Errorf("'resets_f_cnt' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ResetsFCnt = src.ResetsFCnt
			} else {
				dst.ResetsFCnt = nil
			}
		case "status_time_periodicity":
			if len(subs) > 0 {
				return fmt.Errorf("'status_time_periodicity' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.StatusTimePeriodicity = src.StatusTimePeriodicity
			} else {
				dst.StatusTimePeriodicity = nil
			}
		case "status_count_periodicity":
			if len(subs) > 0 {
				return fmt.Errorf("'status_count_periodicity' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.StatusCountPeriodicity = src.StatusCountPeriodicity
			} else {
				dst.StatusCountPeriodicity = nil
			}
		case "desired_rx1_delay":
			if len(subs) > 0 {
				newDst := dst.DesiredRx1Delay
				if newDst == nil {
					newDst = &MACSettings_RxDelayValue{}
					dst.DesiredRx1Delay = newDst
				}
				var newSrc *MACSettings_RxDelayValue
				if src != nil {
					newSrc = src.DesiredRx1Delay
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.DesiredRx1Delay = src.DesiredRx1Delay
				} else {
					dst.DesiredRx1Delay = nil
				}
			}
		case "desired_rx1_data_rate_offset":
			if len(subs) > 0 {
				return fmt.Errorf("'desired_rx1_data_rate_offset' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.DesiredRx1DataRateOffset = src.DesiredRx1DataRateOffset
			} else {
				dst.DesiredRx1DataRateOffset = nil
			}
		case "desired_rx2_data_rate_index":
			if len(subs) > 0 {
				newDst := dst.DesiredRx2DataRateIndex
				if newDst == nil {
					newDst = &MACSettings_DataRateIndexValue{}
					dst.DesiredRx2DataRateIndex = newDst
				}
				var newSrc *MACSettings_DataRateIndexValue
				if src != nil {
					newSrc = src.DesiredRx2DataRateIndex
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.DesiredRx2DataRateIndex = src.DesiredRx2DataRateIndex
				} else {
					dst.DesiredRx2DataRateIndex = nil
				}
			}
		case "desired_rx2_frequency":
			if len(subs) > 0 {
				return fmt.Errorf("'desired_rx2_frequency' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.DesiredRx2Frequency = src.DesiredRx2Frequency
			} else {
				dst.DesiredRx2Frequency = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *MACState) SetFields(src *MACState, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "current_parameters":
			if len(subs) > 0 {
				newDst := &dst.CurrentParameters
				var newSrc *MACParameters
				if src != nil {
					newSrc = &src.CurrentParameters
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.CurrentParameters = src.CurrentParameters
				} else {
					var zero MACParameters
					dst.CurrentParameters = zero
				}
			}
		case "desired_parameters":
			if len(subs) > 0 {
				newDst := &dst.DesiredParameters
				var newSrc *MACParameters
				if src != nil {
					newSrc = &src.DesiredParameters
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.DesiredParameters = src.DesiredParameters
				} else {
					var zero MACParameters
					dst.DesiredParameters = zero
				}
			}
		case "device_class":
			if len(subs) > 0 {
				return fmt.Errorf("'device_class' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.DeviceClass = src.DeviceClass
			} else {
				var zero Class
				dst.DeviceClass = zero
			}
		case "lorawan_version":
			if len(subs) > 0 {
				return fmt.Errorf("'lorawan_version' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LoRaWANVersion = src.LoRaWANVersion
			} else {
				var zero MACVersion
				dst.LoRaWANVersion = zero
			}
		case "last_confirmed_downlink_at":
			if len(subs) > 0 {
				return fmt.Errorf("'last_confirmed_downlink_at' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LastConfirmedDownlinkAt = src.LastConfirmedDownlinkAt
			} else {
				dst.LastConfirmedDownlinkAt = nil
			}
		case "last_dev_status_f_cnt_up":
			if len(subs) > 0 {
				return fmt.Errorf("'last_dev_status_f_cnt_up' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LastDevStatusFCntUp = src.LastDevStatusFCntUp
			} else {
				var zero uint32
				dst.LastDevStatusFCntUp = zero
			}
		case "ping_slot_periodicity":
			if len(subs) > 0 {
				return fmt.Errorf("'ping_slot_periodicity' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.PingSlotPeriodicity = src.PingSlotPeriodicity
			} else {
				var zero PingSlotPeriod
				dst.PingSlotPeriodicity = zero
			}
		case "pending_application_downlink":
			if len(subs) > 0 {
				newDst := dst.PendingApplicationDownlink
				if newDst == nil {
					newDst = &ApplicationDownlink{}
					dst.PendingApplicationDownlink = newDst
				}
				var newSrc *ApplicationDownlink
				if src != nil {
					newSrc = src.PendingApplicationDownlink
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.PendingApplicationDownlink = src.PendingApplicationDownlink
				} else {
					dst.PendingApplicationDownlink = nil
				}
			}
		case "queued_responses":
			if len(subs) > 0 {
				return fmt.Errorf("'queued_responses' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.QueuedResponses = src.QueuedResponses
			} else {
				dst.QueuedResponses = nil
			}
		case "pending_requests":
			if len(subs) > 0 {
				return fmt.Errorf("'pending_requests' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.PendingRequests = src.PendingRequests
			} else {
				dst.PendingRequests = nil
			}
		case "queued_join_accept":
			if len(subs) > 0 {
				newDst := dst.QueuedJoinAccept
				if newDst == nil {
					newDst = &MACState_JoinAccept{}
					dst.QueuedJoinAccept = newDst
				}
				var newSrc *MACState_JoinAccept
				if src != nil {
					newSrc = src.QueuedJoinAccept
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.QueuedJoinAccept = src.QueuedJoinAccept
				} else {
					dst.QueuedJoinAccept = nil
				}
			}
		case "pending_join_request":
			if len(subs) > 0 {
				newDst := dst.PendingJoinRequest
				if newDst == nil {
					newDst = &JoinRequest{}
					dst.PendingJoinRequest = newDst
				}
				var newSrc *JoinRequest
				if src != nil {
					newSrc = src.PendingJoinRequest
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.PendingJoinRequest = src.PendingJoinRequest
				} else {
					dst.PendingJoinRequest = nil
				}
			}
		case "rx_windows_available":
			if len(subs) > 0 {
				return fmt.Errorf("'rx_windows_available' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.RxWindowsAvailable = src.RxWindowsAvailable
			} else {
				var zero bool
				dst.RxWindowsAvailable = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *EndDevice) SetFields(src *EndDevice, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "ids":
			if len(subs) > 0 {
				newDst := &dst.EndDeviceIdentifiers
				var newSrc *EndDeviceIdentifiers
				if src != nil {
					newSrc = &src.EndDeviceIdentifiers
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.EndDeviceIdentifiers = src.EndDeviceIdentifiers
				} else {
					var zero EndDeviceIdentifiers
					dst.EndDeviceIdentifiers = zero
				}
			}
		case "created_at":
			if len(subs) > 0 {
				return fmt.Errorf("'created_at' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.CreatedAt = src.CreatedAt
			} else {
				var zero time.Time
				dst.CreatedAt = zero
			}
		case "updated_at":
			if len(subs) > 0 {
				return fmt.Errorf("'updated_at' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.UpdatedAt = src.UpdatedAt
			} else {
				var zero time.Time
				dst.UpdatedAt = zero
			}
		case "name":
			if len(subs) > 0 {
				return fmt.Errorf("'name' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Name = src.Name
			} else {
				var zero string
				dst.Name = zero
			}
		case "description":
			if len(subs) > 0 {
				return fmt.Errorf("'description' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Description = src.Description
			} else {
				var zero string
				dst.Description = zero
			}
		case "attributes":
			if len(subs) > 0 {
				return fmt.Errorf("'attributes' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Attributes = src.Attributes
			} else {
				dst.Attributes = nil
			}
		case "version_ids":
			if len(subs) > 0 {
				newDst := dst.VersionIDs
				if newDst == nil {
					newDst = &EndDeviceVersionIdentifiers{}
					dst.VersionIDs = newDst
				}
				var newSrc *EndDeviceVersionIdentifiers
				if src != nil {
					newSrc = src.VersionIDs
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.VersionIDs = src.VersionIDs
				} else {
					dst.VersionIDs = nil
				}
			}
		case "service_profile_id":
			if len(subs) > 0 {
				return fmt.Errorf("'service_profile_id' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ServiceProfileID = src.ServiceProfileID
			} else {
				var zero string
				dst.ServiceProfileID = zero
			}
		case "network_server_address":
			if len(subs) > 0 {
				return fmt.Errorf("'network_server_address' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.NetworkServerAddress = src.NetworkServerAddress
			} else {
				var zero string
				dst.NetworkServerAddress = zero
			}
		case "application_server_address":
			if len(subs) > 0 {
				return fmt.Errorf("'application_server_address' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ApplicationServerAddress = src.ApplicationServerAddress
			} else {
				var zero string
				dst.ApplicationServerAddress = zero
			}
		case "join_server_address":
			if len(subs) > 0 {
				return fmt.Errorf("'join_server_address' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.JoinServerAddress = src.JoinServerAddress
			} else {
				var zero string
				dst.JoinServerAddress = zero
			}
		case "locations":
			if len(subs) > 0 {
				return fmt.Errorf("'locations' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Locations = src.Locations
			} else {
				dst.Locations = nil
			}
		case "supports_class_b":
			if len(subs) > 0 {
				return fmt.Errorf("'supports_class_b' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.SupportsClassB = src.SupportsClassB
			} else {
				var zero bool
				dst.SupportsClassB = zero
			}
		case "supports_class_c":
			if len(subs) > 0 {
				return fmt.Errorf("'supports_class_c' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.SupportsClassC = src.SupportsClassC
			} else {
				var zero bool
				dst.SupportsClassC = zero
			}
		case "lorawan_version":
			if len(subs) > 0 {
				return fmt.Errorf("'lorawan_version' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LoRaWANVersion = src.LoRaWANVersion
			} else {
				var zero MACVersion
				dst.LoRaWANVersion = zero
			}
		case "lorawan_phy_version":
			if len(subs) > 0 {
				return fmt.Errorf("'lorawan_phy_version' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LoRaWANPHYVersion = src.LoRaWANPHYVersion
			} else {
				var zero PHYVersion
				dst.LoRaWANPHYVersion = zero
			}
		case "frequency_plan_id":
			if len(subs) > 0 {
				return fmt.Errorf("'frequency_plan_id' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.FrequencyPlanID = src.FrequencyPlanID
			} else {
				var zero string
				dst.FrequencyPlanID = zero
			}
		case "min_frequency":
			if len(subs) > 0 {
				return fmt.Errorf("'min_frequency' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MinFrequency = src.MinFrequency
			} else {
				var zero uint64
				dst.MinFrequency = zero
			}
		case "max_frequency":
			if len(subs) > 0 {
				return fmt.Errorf("'max_frequency' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MaxFrequency = src.MaxFrequency
			} else {
				var zero uint64
				dst.MaxFrequency = zero
			}
		case "supports_join":
			if len(subs) > 0 {
				return fmt.Errorf("'supports_join' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.SupportsJoin = src.SupportsJoin
			} else {
				var zero bool
				dst.SupportsJoin = zero
			}
		case "resets_join_nonces":
			if len(subs) > 0 {
				return fmt.Errorf("'resets_join_nonces' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ResetsJoinNonces = src.ResetsJoinNonces
			} else {
				var zero bool
				dst.ResetsJoinNonces = zero
			}
		case "root_keys":
			if len(subs) > 0 {
				newDst := dst.RootKeys
				if newDst == nil {
					newDst = &RootKeys{}
					dst.RootKeys = newDst
				}
				var newSrc *RootKeys
				if src != nil {
					newSrc = src.RootKeys
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.RootKeys = src.RootKeys
				} else {
					dst.RootKeys = nil
				}
			}
		case "net_id":
			if len(subs) > 0 {
				return fmt.Errorf("'net_id' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.NetID = src.NetID
			} else {
				dst.NetID = nil
			}
		case "mac_settings":
			if len(subs) > 0 {
				newDst := dst.MACSettings
				if newDst == nil {
					newDst = &MACSettings{}
					dst.MACSettings = newDst
				}
				var newSrc *MACSettings
				if src != nil {
					newSrc = src.MACSettings
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.MACSettings = src.MACSettings
				} else {
					dst.MACSettings = nil
				}
			}
		case "mac_state":
			if len(subs) > 0 {
				newDst := dst.MACState
				if newDst == nil {
					newDst = &MACState{}
					dst.MACState = newDst
				}
				var newSrc *MACState
				if src != nil {
					newSrc = src.MACState
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.MACState = src.MACState
				} else {
					dst.MACState = nil
				}
			}
		case "pending_mac_state":
			if len(subs) > 0 {
				newDst := dst.PendingMACState
				if newDst == nil {
					newDst = &MACState{}
					dst.PendingMACState = newDst
				}
				var newSrc *MACState
				if src != nil {
					newSrc = src.PendingMACState
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.PendingMACState = src.PendingMACState
				} else {
					dst.PendingMACState = nil
				}
			}
		case "session":
			if len(subs) > 0 {
				newDst := dst.Session
				if newDst == nil {
					newDst = &Session{}
					dst.Session = newDst
				}
				var newSrc *Session
				if src != nil {
					newSrc = src.Session
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.Session = src.Session
				} else {
					dst.Session = nil
				}
			}
		case "pending_session":
			if len(subs) > 0 {
				newDst := dst.PendingSession
				if newDst == nil {
					newDst = &Session{}
					dst.PendingSession = newDst
				}
				var newSrc *Session
				if src != nil {
					newSrc = src.PendingSession
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.PendingSession = src.PendingSession
				} else {
					dst.PendingSession = nil
				}
			}
		case "last_dev_nonce":
			if len(subs) > 0 {
				return fmt.Errorf("'last_dev_nonce' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LastDevNonce = src.LastDevNonce
			} else {
				var zero uint32
				dst.LastDevNonce = zero
			}
		case "used_dev_nonces":
			if len(subs) > 0 {
				return fmt.Errorf("'used_dev_nonces' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.UsedDevNonces = src.UsedDevNonces
			} else {
				dst.UsedDevNonces = nil
			}
		case "last_join_nonce":
			if len(subs) > 0 {
				return fmt.Errorf("'last_join_nonce' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LastJoinNonce = src.LastJoinNonce
			} else {
				var zero uint32
				dst.LastJoinNonce = zero
			}
		case "last_rj_count_0":
			if len(subs) > 0 {
				return fmt.Errorf("'last_rj_count_0' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LastRJCount0 = src.LastRJCount0
			} else {
				var zero uint32
				dst.LastRJCount0 = zero
			}
		case "last_rj_count_1":
			if len(subs) > 0 {
				return fmt.Errorf("'last_rj_count_1' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LastRJCount1 = src.LastRJCount1
			} else {
				var zero uint32
				dst.LastRJCount1 = zero
			}
		case "last_dev_status_received_at":
			if len(subs) > 0 {
				return fmt.Errorf("'last_dev_status_received_at' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LastDevStatusReceivedAt = src.LastDevStatusReceivedAt
			} else {
				dst.LastDevStatusReceivedAt = nil
			}
		case "power_state":
			if len(subs) > 0 {
				return fmt.Errorf("'power_state' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.PowerState = src.PowerState
			} else {
				var zero PowerState
				dst.PowerState = zero
			}
		case "battery_percentage":
			if len(subs) > 0 {
				return fmt.Errorf("'battery_percentage' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.BatteryPercentage = src.BatteryPercentage
			} else {
				dst.BatteryPercentage = nil
			}
		case "downlink_margin":
			if len(subs) > 0 {
				return fmt.Errorf("'downlink_margin' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.DownlinkMargin = src.DownlinkMargin
			} else {
				var zero int32
				dst.DownlinkMargin = zero
			}
		case "recent_adr_uplinks":
			if len(subs) > 0 {
				return fmt.Errorf("'recent_adr_uplinks' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.RecentADRUplinks = src.RecentADRUplinks
			} else {
				dst.RecentADRUplinks = nil
			}
		case "recent_uplinks":
			if len(subs) > 0 {
				return fmt.Errorf("'recent_uplinks' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.RecentUplinks = src.RecentUplinks
			} else {
				dst.RecentUplinks = nil
			}
		case "recent_downlinks":
			if len(subs) > 0 {
				return fmt.Errorf("'recent_downlinks' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.RecentDownlinks = src.RecentDownlinks
			} else {
				dst.RecentDownlinks = nil
			}
		case "queued_application_downlinks":
			if len(subs) > 0 {
				return fmt.Errorf("'queued_application_downlinks' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.QueuedApplicationDownlinks = src.QueuedApplicationDownlinks
			} else {
				dst.QueuedApplicationDownlinks = nil
			}
		case "formatters":
			if len(subs) > 0 {
				newDst := dst.Formatters
				if newDst == nil {
					newDst = &MessagePayloadFormatters{}
					dst.Formatters = newDst
				}
				var newSrc *MessagePayloadFormatters
				if src != nil {
					newSrc = src.Formatters
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.Formatters = src.Formatters
				} else {
					dst.Formatters = nil
				}
			}
		case "provisioner_id":
			if len(subs) > 0 {
				return fmt.Errorf("'provisioner_id' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ProvisionerID = src.ProvisionerID
			} else {
				var zero string
				dst.ProvisionerID = zero
			}
		case "provisioning_data":
			if len(subs) > 0 {
				return fmt.Errorf("'provisioning_data' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ProvisioningData = src.ProvisioningData
			} else {
				dst.ProvisioningData = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *EndDevices) SetFields(src *EndDevices, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "end_devices":
			if len(subs) > 0 {
				return fmt.Errorf("'end_devices' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.EndDevices = src.EndDevices
			} else {
				dst.EndDevices = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *CreateEndDeviceRequest) SetFields(src *CreateEndDeviceRequest, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "end_device":
			if len(subs) > 0 {
				newDst := &dst.EndDevice
				var newSrc *EndDevice
				if src != nil {
					newSrc = &src.EndDevice
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.EndDevice = src.EndDevice
				} else {
					var zero EndDevice
					dst.EndDevice = zero
				}
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *UpdateEndDeviceRequest) SetFields(src *UpdateEndDeviceRequest, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "end_device":
			if len(subs) > 0 {
				newDst := &dst.EndDevice
				var newSrc *EndDevice
				if src != nil {
					newSrc = &src.EndDevice
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.EndDevice = src.EndDevice
				} else {
					var zero EndDevice
					dst.EndDevice = zero
				}
			}
		case "field_mask":
			if len(subs) > 0 {
				return fmt.Errorf("'field_mask' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.FieldMask = src.FieldMask
			} else {
				var zero types.FieldMask
				dst.FieldMask = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *GetEndDeviceRequest) SetFields(src *GetEndDeviceRequest, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "end_device_ids":
			if len(subs) > 0 {
				newDst := &dst.EndDeviceIdentifiers
				var newSrc *EndDeviceIdentifiers
				if src != nil {
					newSrc = &src.EndDeviceIdentifiers
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.EndDeviceIdentifiers = src.EndDeviceIdentifiers
				} else {
					var zero EndDeviceIdentifiers
					dst.EndDeviceIdentifiers = zero
				}
			}
		case "field_mask":
			if len(subs) > 0 {
				return fmt.Errorf("'field_mask' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.FieldMask = src.FieldMask
			} else {
				var zero types.FieldMask
				dst.FieldMask = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *ListEndDevicesRequest) SetFields(src *ListEndDevicesRequest, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "application_ids":
			if len(subs) > 0 {
				newDst := &dst.ApplicationIdentifiers
				var newSrc *ApplicationIdentifiers
				if src != nil {
					newSrc = &src.ApplicationIdentifiers
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.ApplicationIdentifiers = src.ApplicationIdentifiers
				} else {
					var zero ApplicationIdentifiers
					dst.ApplicationIdentifiers = zero
				}
			}
		case "field_mask":
			if len(subs) > 0 {
				return fmt.Errorf("'field_mask' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.FieldMask = src.FieldMask
			} else {
				var zero types.FieldMask
				dst.FieldMask = zero
			}
		case "order":
			if len(subs) > 0 {
				return fmt.Errorf("'order' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Order = src.Order
			} else {
				var zero string
				dst.Order = zero
			}
		case "limit":
			if len(subs) > 0 {
				return fmt.Errorf("'limit' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Limit = src.Limit
			} else {
				var zero uint32
				dst.Limit = zero
			}
		case "page":
			if len(subs) > 0 {
				return fmt.Errorf("'page' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Page = src.Page
			} else {
				var zero uint32
				dst.Page = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *SetEndDeviceRequest) SetFields(src *SetEndDeviceRequest, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "end_device":
			if len(subs) > 0 {
				newDst := &dst.EndDevice
				var newSrc *EndDevice
				if src != nil {
					newSrc = &src.EndDevice
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.EndDevice = src.EndDevice
				} else {
					var zero EndDevice
					dst.EndDevice = zero
				}
			}
		case "field_mask":
			if len(subs) > 0 {
				return fmt.Errorf("'field_mask' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.FieldMask = src.FieldMask
			} else {
				var zero types.FieldMask
				dst.FieldMask = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *MACParameters_Channel) SetFields(src *MACParameters_Channel, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "uplink_frequency":
			if len(subs) > 0 {
				return fmt.Errorf("'uplink_frequency' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.UplinkFrequency = src.UplinkFrequency
			} else {
				var zero uint64
				dst.UplinkFrequency = zero
			}
		case "downlink_frequency":
			if len(subs) > 0 {
				return fmt.Errorf("'downlink_frequency' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.DownlinkFrequency = src.DownlinkFrequency
			} else {
				var zero uint64
				dst.DownlinkFrequency = zero
			}
		case "min_data_rate_index":
			if len(subs) > 0 {
				return fmt.Errorf("'min_data_rate_index' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MinDataRateIndex = src.MinDataRateIndex
			} else {
				var zero DataRateIndex
				dst.MinDataRateIndex = zero
			}
		case "max_data_rate_index":
			if len(subs) > 0 {
				return fmt.Errorf("'max_data_rate_index' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MaxDataRateIndex = src.MaxDataRateIndex
			} else {
				var zero DataRateIndex
				dst.MaxDataRateIndex = zero
			}
		case "enable_uplink":
			if len(subs) > 0 {
				return fmt.Errorf("'enable_uplink' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.EnableUplink = src.EnableUplink
			} else {
				var zero bool
				dst.EnableUplink = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *MACSettings_DataRateIndexValue) SetFields(src *MACSettings_DataRateIndexValue, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "value":
			if len(subs) > 0 {
				return fmt.Errorf("'value' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Value = src.Value
			} else {
				var zero DataRateIndex
				dst.Value = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *MACSettings_PingSlotPeriodValue) SetFields(src *MACSettings_PingSlotPeriodValue, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "value":
			if len(subs) > 0 {
				return fmt.Errorf("'value' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Value = src.Value
			} else {
				var zero PingSlotPeriod
				dst.Value = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *MACSettings_AggregatedDutyCycleValue) SetFields(src *MACSettings_AggregatedDutyCycleValue, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "value":
			if len(subs) > 0 {
				return fmt.Errorf("'value' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Value = src.Value
			} else {
				var zero AggregatedDutyCycle
				dst.Value = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *MACSettings_RxDelayValue) SetFields(src *MACSettings_RxDelayValue, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "value":
			if len(subs) > 0 {
				return fmt.Errorf("'value' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Value = src.Value
			} else {
				var zero RxDelay
				dst.Value = zero
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *MACState_JoinAccept) SetFields(src *MACState_JoinAccept, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "payload":
			if len(subs) > 0 {
				return fmt.Errorf("'payload' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Payload = src.Payload
			} else {
				dst.Payload = nil
			}
		case "request":
			if len(subs) > 0 {
				newDst := &dst.Request
				var newSrc *JoinRequest
				if src != nil {
					newSrc = &src.Request
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.Request = src.Request
				} else {
					var zero JoinRequest
					dst.Request = zero
				}
			}
		case "keys":
			if len(subs) > 0 {
				newDst := &dst.Keys
				var newSrc *SessionKeys
				if src != nil {
					newSrc = &src.Keys
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.Keys = src.Keys
				} else {
					var zero SessionKeys
					dst.Keys = zero
				}
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}
