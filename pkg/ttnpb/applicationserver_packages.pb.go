// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lorawan-stack/api/applicationserver_packages.proto

package ttnpb

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
	time "time"

	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ApplicationPackage struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DefaultFPort         uint32   `protobuf:"varint,2,opt,name=default_f_port,json=defaultFPort,proto3" json:"default_f_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ApplicationPackage) Reset()      { *m = ApplicationPackage{} }
func (*ApplicationPackage) ProtoMessage() {}
func (*ApplicationPackage) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4ce58e965b6ca0, []int{0}
}
func (m *ApplicationPackage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplicationPackage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplicationPackage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplicationPackage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationPackage.Merge(m, src)
}
func (m *ApplicationPackage) XXX_Size() int {
	return m.Size()
}
func (m *ApplicationPackage) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationPackage.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationPackage proto.InternalMessageInfo

func (m *ApplicationPackage) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ApplicationPackage) GetDefaultFPort() uint32 {
	if m != nil {
		return m.DefaultFPort
	}
	return 0
}

type ApplicationPackages struct {
	Packages             []*ApplicationPackage `protobuf:"bytes,1,rep,name=packages,proto3" json:"packages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ApplicationPackages) Reset()      { *m = ApplicationPackages{} }
func (*ApplicationPackages) ProtoMessage() {}
func (*ApplicationPackages) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4ce58e965b6ca0, []int{1}
}
func (m *ApplicationPackages) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplicationPackages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplicationPackages.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplicationPackages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationPackages.Merge(m, src)
}
func (m *ApplicationPackages) XXX_Size() int {
	return m.Size()
}
func (m *ApplicationPackages) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationPackages.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationPackages proto.InternalMessageInfo

func (m *ApplicationPackages) GetPackages() []*ApplicationPackage {
	if m != nil {
		return m.Packages
	}
	return nil
}

type ApplicationPackageAssociationIdentifiers struct {
	EndDeviceIdentifiers `protobuf:"bytes,1,opt,name=end_device_ids,json=endDeviceIds,proto3,embedded=end_device_ids" json:"end_device_ids"`
	FPort                uint32   `protobuf:"varint,2,opt,name=f_port,json=fPort,proto3" json:"f_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ApplicationPackageAssociationIdentifiers) Reset() {
	*m = ApplicationPackageAssociationIdentifiers{}
}
func (*ApplicationPackageAssociationIdentifiers) ProtoMessage() {}
func (*ApplicationPackageAssociationIdentifiers) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4ce58e965b6ca0, []int{2}
}
func (m *ApplicationPackageAssociationIdentifiers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplicationPackageAssociationIdentifiers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplicationPackageAssociationIdentifiers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplicationPackageAssociationIdentifiers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationPackageAssociationIdentifiers.Merge(m, src)
}
func (m *ApplicationPackageAssociationIdentifiers) XXX_Size() int {
	return m.Size()
}
func (m *ApplicationPackageAssociationIdentifiers) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationPackageAssociationIdentifiers.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationPackageAssociationIdentifiers proto.InternalMessageInfo

func (m *ApplicationPackageAssociationIdentifiers) GetFPort() uint32 {
	if m != nil {
		return m.FPort
	}
	return 0
}

type ApplicationPackageAssociation struct {
	ApplicationPackageAssociationIdentifiers `protobuf:"bytes,1,opt,name=ids,proto3,embedded=ids" json:"ids"`
	CreatedAt                                time.Time     `protobuf:"bytes,2,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
	UpdatedAt                                time.Time     `protobuf:"bytes,3,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at"`
	PackageName                              string        `protobuf:"bytes,4,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	Data                                     *types.Struct `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral                     struct{}      `json:"-"`
	XXX_sizecache                            int32         `json:"-"`
}

func (m *ApplicationPackageAssociation) Reset()      { *m = ApplicationPackageAssociation{} }
func (*ApplicationPackageAssociation) ProtoMessage() {}
func (*ApplicationPackageAssociation) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4ce58e965b6ca0, []int{3}
}
func (m *ApplicationPackageAssociation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplicationPackageAssociation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplicationPackageAssociation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplicationPackageAssociation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationPackageAssociation.Merge(m, src)
}
func (m *ApplicationPackageAssociation) XXX_Size() int {
	return m.Size()
}
func (m *ApplicationPackageAssociation) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationPackageAssociation.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationPackageAssociation proto.InternalMessageInfo

func (m *ApplicationPackageAssociation) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *ApplicationPackageAssociation) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

func (m *ApplicationPackageAssociation) GetPackageName() string {
	if m != nil {
		return m.PackageName
	}
	return ""
}

func (m *ApplicationPackageAssociation) GetData() *types.Struct {
	if m != nil {
		return m.Data
	}
	return nil
}

type ApplicationPackageAssociations struct {
	Associations         []*ApplicationPackageAssociation `protobuf:"bytes,1,rep,name=associations,proto3" json:"associations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *ApplicationPackageAssociations) Reset()      { *m = ApplicationPackageAssociations{} }
func (*ApplicationPackageAssociations) ProtoMessage() {}
func (*ApplicationPackageAssociations) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4ce58e965b6ca0, []int{4}
}
func (m *ApplicationPackageAssociations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplicationPackageAssociations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplicationPackageAssociations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplicationPackageAssociations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationPackageAssociations.Merge(m, src)
}
func (m *ApplicationPackageAssociations) XXX_Size() int {
	return m.Size()
}
func (m *ApplicationPackageAssociations) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationPackageAssociations.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationPackageAssociations proto.InternalMessageInfo

func (m *ApplicationPackageAssociations) GetAssociations() []*ApplicationPackageAssociation {
	if m != nil {
		return m.Associations
	}
	return nil
}

type GetApplicationPackageAssociationRequest struct {
	ApplicationPackageAssociationIdentifiers `protobuf:"bytes,1,opt,name=ids,proto3,embedded=ids" json:"ids"`
	FieldMask                                types.FieldMask `protobuf:"bytes,2,opt,name=field_mask,json=fieldMask,proto3" json:"field_mask"`
	XXX_NoUnkeyedLiteral                     struct{}        `json:"-"`
	XXX_sizecache                            int32           `json:"-"`
}

func (m *GetApplicationPackageAssociationRequest) Reset() {
	*m = GetApplicationPackageAssociationRequest{}
}
func (*GetApplicationPackageAssociationRequest) ProtoMessage() {}
func (*GetApplicationPackageAssociationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4ce58e965b6ca0, []int{5}
}
func (m *GetApplicationPackageAssociationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetApplicationPackageAssociationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetApplicationPackageAssociationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetApplicationPackageAssociationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetApplicationPackageAssociationRequest.Merge(m, src)
}
func (m *GetApplicationPackageAssociationRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetApplicationPackageAssociationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetApplicationPackageAssociationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetApplicationPackageAssociationRequest proto.InternalMessageInfo

func (m *GetApplicationPackageAssociationRequest) GetFieldMask() types.FieldMask {
	if m != nil {
		return m.FieldMask
	}
	return types.FieldMask{}
}

type ListApplicationPackageAssociationRequest struct {
	EndDeviceIdentifiers `protobuf:"bytes,1,opt,name=ids,proto3,embedded=ids" json:"ids"`
	// Limit the number of results per page.
	// Each page is ordered by the FPort.
	Limit uint32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	// Page number for pagination. 0 is interpreted as 1.
	Page                 uint32          `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
	FieldMask            types.FieldMask `protobuf:"bytes,4,opt,name=field_mask,json=fieldMask,proto3" json:"field_mask"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ListApplicationPackageAssociationRequest) Reset() {
	*m = ListApplicationPackageAssociationRequest{}
}
func (*ListApplicationPackageAssociationRequest) ProtoMessage() {}
func (*ListApplicationPackageAssociationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4ce58e965b6ca0, []int{6}
}
func (m *ListApplicationPackageAssociationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListApplicationPackageAssociationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListApplicationPackageAssociationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListApplicationPackageAssociationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListApplicationPackageAssociationRequest.Merge(m, src)
}
func (m *ListApplicationPackageAssociationRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListApplicationPackageAssociationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListApplicationPackageAssociationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListApplicationPackageAssociationRequest proto.InternalMessageInfo

func (m *ListApplicationPackageAssociationRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListApplicationPackageAssociationRequest) GetPage() uint32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *ListApplicationPackageAssociationRequest) GetFieldMask() types.FieldMask {
	if m != nil {
		return m.FieldMask
	}
	return types.FieldMask{}
}

type SetApplicationPackageAssociationRequest struct {
	ApplicationPackageAssociation `protobuf:"bytes,1,opt,name=association,proto3,embedded=association" json:"association"`
	FieldMask                     types.FieldMask `protobuf:"bytes,2,opt,name=field_mask,json=fieldMask,proto3" json:"field_mask"`
	XXX_NoUnkeyedLiteral          struct{}        `json:"-"`
	XXX_sizecache                 int32           `json:"-"`
}

func (m *SetApplicationPackageAssociationRequest) Reset() {
	*m = SetApplicationPackageAssociationRequest{}
}
func (*SetApplicationPackageAssociationRequest) ProtoMessage() {}
func (*SetApplicationPackageAssociationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4ce58e965b6ca0, []int{7}
}
func (m *SetApplicationPackageAssociationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetApplicationPackageAssociationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetApplicationPackageAssociationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetApplicationPackageAssociationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetApplicationPackageAssociationRequest.Merge(m, src)
}
func (m *SetApplicationPackageAssociationRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetApplicationPackageAssociationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetApplicationPackageAssociationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetApplicationPackageAssociationRequest proto.InternalMessageInfo

func (m *SetApplicationPackageAssociationRequest) GetFieldMask() types.FieldMask {
	if m != nil {
		return m.FieldMask
	}
	return types.FieldMask{}
}

func init() {
	proto.RegisterType((*ApplicationPackage)(nil), "ttn.lorawan.v3.ApplicationPackage")
	golang_proto.RegisterType((*ApplicationPackage)(nil), "ttn.lorawan.v3.ApplicationPackage")
	proto.RegisterType((*ApplicationPackages)(nil), "ttn.lorawan.v3.ApplicationPackages")
	golang_proto.RegisterType((*ApplicationPackages)(nil), "ttn.lorawan.v3.ApplicationPackages")
	proto.RegisterType((*ApplicationPackageAssociationIdentifiers)(nil), "ttn.lorawan.v3.ApplicationPackageAssociationIdentifiers")
	golang_proto.RegisterType((*ApplicationPackageAssociationIdentifiers)(nil), "ttn.lorawan.v3.ApplicationPackageAssociationIdentifiers")
	proto.RegisterType((*ApplicationPackageAssociation)(nil), "ttn.lorawan.v3.ApplicationPackageAssociation")
	golang_proto.RegisterType((*ApplicationPackageAssociation)(nil), "ttn.lorawan.v3.ApplicationPackageAssociation")
	proto.RegisterType((*ApplicationPackageAssociations)(nil), "ttn.lorawan.v3.ApplicationPackageAssociations")
	golang_proto.RegisterType((*ApplicationPackageAssociations)(nil), "ttn.lorawan.v3.ApplicationPackageAssociations")
	proto.RegisterType((*GetApplicationPackageAssociationRequest)(nil), "ttn.lorawan.v3.GetApplicationPackageAssociationRequest")
	golang_proto.RegisterType((*GetApplicationPackageAssociationRequest)(nil), "ttn.lorawan.v3.GetApplicationPackageAssociationRequest")
	proto.RegisterType((*ListApplicationPackageAssociationRequest)(nil), "ttn.lorawan.v3.ListApplicationPackageAssociationRequest")
	golang_proto.RegisterType((*ListApplicationPackageAssociationRequest)(nil), "ttn.lorawan.v3.ListApplicationPackageAssociationRequest")
	proto.RegisterType((*SetApplicationPackageAssociationRequest)(nil), "ttn.lorawan.v3.SetApplicationPackageAssociationRequest")
	golang_proto.RegisterType((*SetApplicationPackageAssociationRequest)(nil), "ttn.lorawan.v3.SetApplicationPackageAssociationRequest")
}

func init() {
	proto.RegisterFile("lorawan-stack/api/applicationserver_packages.proto", fileDescriptor_aa4ce58e965b6ca0)
}
func init() {
	golang_proto.RegisterFile("lorawan-stack/api/applicationserver_packages.proto", fileDescriptor_aa4ce58e965b6ca0)
}

var fileDescriptor_aa4ce58e965b6ca0 = []byte{
	// 1100 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x4d, 0x6c, 0x1b, 0x45,
	0x14, 0xde, 0x49, 0xec, 0x36, 0x99, 0xa4, 0x51, 0x18, 0x24, 0xb0, 0x0c, 0x4c, 0xc2, 0x36, 0x52,
	0x4c, 0xc0, 0xbb, 0x95, 0x73, 0x00, 0x8a, 0x44, 0x14, 0xd3, 0x96, 0x1f, 0x41, 0x15, 0x36, 0xc0,
	0x81, 0xb6, 0x58, 0x93, 0xdd, 0xf1, 0x66, 0x65, 0x7b, 0x77, 0xd9, 0x19, 0xbb, 0x84, 0x28, 0x52,
	0x54, 0x84, 0x54, 0x21, 0x84, 0x8a, 0x7a, 0xe9, 0x91, 0x0b, 0x52, 0x11, 0x97, 0x8a, 0x53, 0xc4,
	0x85, 0x1e, 0x73, 0x41, 0x8a, 0xc4, 0xa5, 0xa7, 0x52, 0xaf, 0x39, 0xa4, 0xb7, 0x1e, 0x38, 0x54,
	0x39, 0x40, 0xb5, 0xb3, 0xeb, 0x64, 0xfd, 0xd3, 0xd8, 0x4e, 0xd5, 0xdb, 0xce, 0xce, 0xfb, 0xde,
	0xbe, 0xef, 0x7b, 0xdf, 0xbc, 0x59, 0x98, 0x2b, 0x3b, 0x1e, 0xb9, 0x4c, 0xec, 0x2c, 0xe3, 0x44,
	0x2f, 0xa9, 0xc4, 0xb5, 0x54, 0xe2, 0xba, 0x65, 0x4b, 0x27, 0xdc, 0x72, 0x6c, 0x46, 0xbd, 0x1a,
	0xf5, 0x0a, 0x2e, 0xd1, 0x4b, 0xc4, 0xa4, 0x4c, 0x71, 0x3d, 0x87, 0x3b, 0x68, 0x82, 0x73, 0x5b,
	0x89, 0x70, 0x4a, 0x6d, 0x3e, 0xbd, 0x68, 0x5a, 0x7c, 0xb5, 0xba, 0xa2, 0xe8, 0x4e, 0x45, 0xa5,
	0x76, 0xcd, 0x59, 0x73, 0x3d, 0xe7, 0xab, 0x35, 0x55, 0x04, 0xeb, 0x59, 0x93, 0xda, 0xd9, 0x1a,
	0x29, 0x5b, 0x06, 0xe1, 0x54, 0xed, 0x78, 0x08, 0x53, 0xa6, 0xb3, 0xb1, 0x14, 0xa6, 0x63, 0x3a,
	0x21, 0x78, 0xa5, 0x5a, 0x14, 0x2b, 0xb1, 0x10, 0x4f, 0x51, 0xf8, 0x8b, 0xa6, 0xe3, 0x98, 0x65,
	0x1a, 0x96, 0x6b, 0xdb, 0x0e, 0x0f, 0xab, 0x8d, 0x76, 0x5f, 0x88, 0x76, 0xf7, 0x73, 0xd0, 0x8a,
	0xcb, 0xd7, 0xa2, 0xcd, 0xe9, 0xf6, 0xcd, 0xa2, 0x45, 0xcb, 0x46, 0xa1, 0x42, 0x58, 0x29, 0x8a,
	0x98, 0x6a, 0x8f, 0xe0, 0x56, 0x85, 0x32, 0x4e, 0x2a, 0x6e, 0xdb, 0xd7, 0xf7, 0x03, 0x18, 0xf7,
	0xaa, 0x3a, 0x8f, 0x76, 0x4f, 0x76, 0x2a, 0x6a, 0x19, 0xd4, 0xe6, 0x56, 0xd1, 0xa2, 0x5e, 0x54,
	0xa2, 0xfc, 0x0d, 0x80, 0x68, 0xf1, 0x40, 0xe7, 0xa5, 0x50, 0x60, 0xf4, 0x16, 0x4c, 0xd8, 0xa4,
	0x42, 0x53, 0x60, 0x1a, 0x64, 0x46, 0xf3, 0xb3, 0x7b, 0xf9, 0x19, 0x4f, 0x4e, 0xcd, 0xe4, 0xf0,
	0x17, 0x17, 0x48, 0xf6, 0xeb, 0x53, 0xd9, 0x37, 0x2f, 0x65, 0x16, 0x4e, 0x5f, 0xc8, 0x5e, 0x5a,
	0x68, 0x2e, 0x5f, 0x59, 0xcf, 0xbd, 0xb6, 0x31, 0xa3, 0x09, 0x10, 0x3a, 0x05, 0x27, 0x0c, 0x5a,
	0x24, 0xd5, 0x32, 0x2f, 0x14, 0x0b, 0xae, 0xe3, 0xf1, 0xd4, 0xd0, 0x34, 0xc8, 0x9c, 0xc8, 0xc3,
	0xbd, 0xfc, 0xf1, 0xb9, 0x64, 0xea, 0x7f, 0x90, 0x01, 0xda, 0x78, 0x14, 0x71, 0x6e, 0xc9, 0xf1,
	0xb8, 0xfc, 0x29, 0x7c, 0xb6, 0xb3, 0x08, 0x86, 0xde, 0x86, 0x23, 0xcd, 0x8e, 0xa7, 0xc0, 0xf4,
	0x70, 0x66, 0x2c, 0x27, 0x2b, 0xad, 0x2d, 0x57, 0x3a, 0x61, 0xda, 0x3e, 0x46, 0xfe, 0x15, 0xc0,
	0x4c, 0x67, 0xc0, 0x22, 0x63, 0x8e, 0x6e, 0x89, 0x37, 0xef, 0x1f, 0xe8, 0x81, 0x2e, 0xc2, 0x09,
	0x6a, 0x1b, 0x05, 0x83, 0xd6, 0x2c, 0x9d, 0x16, 0x2c, 0x83, 0x09, 0xf2, 0x63, 0xb9, 0x99, 0xf6,
	0x4f, 0x9e, 0xb5, 0x8d, 0x33, 0x22, 0x28, 0x86, 0xce, 0x4f, 0xee, 0xe5, 0x93, 0xdf, 0x81, 0xa1,
	0x49, 0xb0, 0x7d, 0x77, 0x4a, 0xda, 0xb9, 0x3b, 0x05, 0xb4, 0x71, 0x7a, 0x10, 0xc7, 0xd0, 0xcb,
	0xf0, 0xd8, 0x63, 0xb5, 0x48, 0x16, 0x85, 0x08, 0x9b, 0xc3, 0xf0, 0xa5, 0x43, 0xab, 0x45, 0x17,
	0xe1, 0xf0, 0x41, 0x5d, 0x6f, 0xf4, 0x96, 0xa2, 0x3b, 0xd3, 0x2e, 0xb5, 0x06, 0x69, 0xd1, 0x3b,
	0x10, 0xea, 0x1e, 0x25, 0x9c, 0x1a, 0x05, 0x12, 0x96, 0x39, 0x96, 0x4b, 0x2b, 0xa1, 0xc5, 0x94,
	0xa6, 0xc5, 0x94, 0x4f, 0x9a, 0x1e, 0xcc, 0x8f, 0x04, 0xf0, 0x6b, 0x7f, 0x4f, 0x01, 0x6d, 0x34,
	0xc2, 0x2d, 0xf2, 0x20, 0x49, 0xd5, 0x35, 0x9a, 0x49, 0x86, 0x07, 0x49, 0x12, 0xe1, 0x16, 0x39,
	0xfa, 0x00, 0x8e, 0x47, 0x3d, 0x2c, 0x08, 0x17, 0x26, 0x06, 0x73, 0xe1, 0x58, 0x04, 0x3e, 0x1f,
	0x98, 0xf1, 0x55, 0x98, 0x30, 0x08, 0x27, 0xa9, 0xa4, 0x28, 0xe5, 0xf9, 0x8e, 0x52, 0x96, 0xc5,
	0x91, 0xd1, 0x44, 0x90, 0xcc, 0x20, 0x3e, 0x54, 0x45, 0x86, 0x3e, 0x86, 0xe3, 0x24, 0xb6, 0x8e,
	0x6c, 0x99, 0x1d, 0xa8, 0x17, 0x5a, 0x4b, 0x0a, 0x79, 0x1b, 0xc0, 0xd9, 0x77, 0x29, 0x3f, 0x1c,
	0x42, 0xbf, 0xac, 0x52, 0xc6, 0x9f, 0xb2, 0x03, 0x16, 0x20, 0x3c, 0x18, 0x42, 0x8f, 0x75, 0xc0,
	0xb9, 0x20, 0xe4, 0x23, 0xc2, 0x4a, 0xf9, 0x44, 0x00, 0xd7, 0x46, 0x8b, 0xcd, 0x17, 0xf2, 0x7d,
	0x00, 0x33, 0x1f, 0x5a, 0xac, 0x3f, 0x2e, 0xef, 0xc5, 0xb9, 0x1c, 0xf5, 0x94, 0x89, 0xba, 0x31,
	0x4c, 0x96, 0xad, 0x8a, 0xd5, 0x3c, 0x5b, 0x23, 0x7b, 0xf9, 0xe4, 0xdc, 0x70, 0x6a, 0xf7, 0xb8,
	0x16, 0xbe, 0x46, 0x08, 0x26, 0x5c, 0x62, 0x52, 0x61, 0xc7, 0x13, 0x9a, 0x78, 0x6e, 0xe3, 0x9a,
	0x18, 0x9c, 0xeb, 0x9f, 0x00, 0xce, 0x2e, 0xf7, 0xd9, 0x36, 0x02, 0xc7, 0x62, 0x2d, 0x8f, 0x28,
	0x0f, 0x66, 0x9a, 0x2e, 0xdc, 0xe3, 0x39, 0x9f, 0xb8, 0x77, 0xb9, 0xff, 0x46, 0x61, 0xba, 0xcb,
	0x34, 0xa5, 0xa6, 0xc5, 0xb8, 0xb7, 0x86, 0x7e, 0x01, 0x30, 0x11, 0xb4, 0x16, 0xf5, 0xd5, 0xa9,
	0xf4, 0xc9, 0xde, 0xe4, 0x98, 0xfc, 0xd9, 0x95, 0xbf, 0xfe, 0xb9, 0x3e, 0xb4, 0x84, 0xce, 0xab,
	0x84, 0xb5, 0xdc, 0xf6, 0xea, 0x7a, 0x6c, 0x15, 0xcc, 0x62, 0xa5, 0x75, 0xbd, 0xa1, 0x86, 0x63,
	0x9a, 0xa9, 0xeb, 0xfb, 0xf3, 0x7a, 0x43, 0x6d, 0xce, 0x7d, 0x74, 0x7d, 0x08, 0x4e, 0x04, 0x27,
	0x2a, 0x26, 0xcf, 0xeb, 0xed, 0xf5, 0xf4, 0x79, 0xe2, 0xd2, 0x83, 0x75, 0x49, 0xbe, 0x01, 0x04,
	0xa7, 0x1f, 0x01, 0xfa, 0x01, 0x74, 0xb2, 0x0a, 0x98, 0xb4, 0x5e, 0x32, 0x4a, 0xdf, 0x44, 0xbb,
	0x60, 0xbb, 0x70, 0x57, 0xe3, 0xa3, 0x25, 0x04, 0x85, 0xf7, 0xce, 0x06, 0xba, 0x0f, 0xe0, 0xa4,
	0x38, 0x9c, 0xf1, 0x79, 0xd6, 0x31, 0x43, 0xfa, 0x3d, 0xbe, 0x69, 0x65, 0x20, 0x61, 0x98, 0x5c,
	0x12, 0xc2, 0x50, 0xa4, 0x77, 0x97, 0x65, 0x20, 0x1d, 0x7a, 0x11, 0x47, 0xbf, 0x0f, 0xc1, 0x89,
	0xe5, 0x1e, 0x0e, 0x58, 0x7e, 0x3a, 0x0e, 0xf8, 0x23, 0x74, 0xc0, 0x16, 0x48, 0xff, 0xd6, 0xc5,
	0x01, 0xb1, 0x2a, 0x95, 0x27, 0x71, 0x43, 0x8f, 0x3c, 0xbd, 0x9d, 0xd1, 0x9e, 0x20, 0x72, 0xc9,
	0x69, 0x30, 0x87, 0xfe, 0x05, 0xf0, 0x99, 0x33, 0xb4, 0x4c, 0x79, 0xcb, 0xcf, 0xc7, 0x91, 0x6f,
	0x9b, 0xf4, 0x73, 0x1d, 0x63, 0xe8, 0x6c, 0xf0, 0x1f, 0x2c, 0x7f, 0x1f, 0x2a, 0xf5, 0x2d, 0x98,
	0xbb, 0xd2, 0x45, 0xa9, 0xa3, 0x2a, 0x33, 0xb0, 0x12, 0x11, 0xf3, 0xfc, 0xcf, 0x60, 0xbb, 0x8e,
	0xc1, 0x4e, 0x1d, 0x83, 0x3b, 0x75, 0x2c, 0xdd, 0xab, 0x63, 0x69, 0xb7, 0x8e, 0xa5, 0x07, 0x75,
	0x2c, 0x3d, 0xac, 0x63, 0xb0, 0xe9, 0x63, 0x70, 0xd5, 0xc7, 0xd2, 0x4d, 0x1f, 0x83, 0x5b, 0x3e,
	0x96, 0xb6, 0x7c, 0x2c, 0xdd, 0xf6, 0xb1, 0xb4, 0xed, 0x63, 0xb0, 0xe3, 0x63, 0x70, 0xc7, 0xc7,
	0xd2, 0x3d, 0x1f, 0x83, 0x5d, 0x1f, 0x4b, 0x0f, 0x7c, 0x0c, 0x1e, 0xfa, 0x58, 0xda, 0x6c, 0x60,
	0xe9, 0x6a, 0x03, 0x83, 0x6b, 0x0d, 0x2c, 0xdd, 0x68, 0x60, 0xf0, 0x53, 0x03, 0x4b, 0x37, 0x1b,
	0x58, 0xba, 0xd5, 0xc0, 0x60, 0xab, 0x81, 0xc1, 0xed, 0x06, 0x06, 0x9f, 0xab, 0xa6, 0xa3, 0xf0,
	0x55, 0xca, 0x57, 0x2d, 0xdb, 0x64, 0x8a, 0x4d, 0xf9, 0x65, 0xc7, 0x2b, 0xa9, 0xad, 0xff, 0xee,
	0xb5, 0x79, 0xd5, 0x2d, 0x99, 0x2a, 0xe7, 0xb6, 0xbb, 0xb2, 0x72, 0x4c, 0xc8, 0x38, 0xff, 0x28,
	0x00, 0x00, 0xff, 0xff, 0x36, 0x02, 0x98, 0xa8, 0x32, 0x0d, 0x00, 0x00,
}

func (this *ApplicationPackage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplicationPackage)
	if !ok {
		that2, ok := that.(ApplicationPackage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.DefaultFPort != that1.DefaultFPort {
		return false
	}
	return true
}
func (this *ApplicationPackages) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplicationPackages)
	if !ok {
		that2, ok := that.(ApplicationPackages)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Packages) != len(that1.Packages) {
		return false
	}
	for i := range this.Packages {
		if !this.Packages[i].Equal(that1.Packages[i]) {
			return false
		}
	}
	return true
}
func (this *ApplicationPackageAssociationIdentifiers) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplicationPackageAssociationIdentifiers)
	if !ok {
		that2, ok := that.(ApplicationPackageAssociationIdentifiers)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EndDeviceIdentifiers.Equal(&that1.EndDeviceIdentifiers) {
		return false
	}
	if this.FPort != that1.FPort {
		return false
	}
	return true
}
func (this *ApplicationPackageAssociation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplicationPackageAssociation)
	if !ok {
		that2, ok := that.(ApplicationPackageAssociation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ApplicationPackageAssociationIdentifiers.Equal(&that1.ApplicationPackageAssociationIdentifiers) {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if this.PackageName != that1.PackageName {
		return false
	}
	if !this.Data.Equal(that1.Data) {
		return false
	}
	return true
}
func (this *ApplicationPackageAssociations) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplicationPackageAssociations)
	if !ok {
		that2, ok := that.(ApplicationPackageAssociations)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Associations) != len(that1.Associations) {
		return false
	}
	for i := range this.Associations {
		if !this.Associations[i].Equal(that1.Associations[i]) {
			return false
		}
	}
	return true
}
func (this *GetApplicationPackageAssociationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetApplicationPackageAssociationRequest)
	if !ok {
		that2, ok := that.(GetApplicationPackageAssociationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ApplicationPackageAssociationIdentifiers.Equal(&that1.ApplicationPackageAssociationIdentifiers) {
		return false
	}
	if !this.FieldMask.Equal(&that1.FieldMask) {
		return false
	}
	return true
}
func (this *ListApplicationPackageAssociationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListApplicationPackageAssociationRequest)
	if !ok {
		that2, ok := that.(ListApplicationPackageAssociationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EndDeviceIdentifiers.Equal(&that1.EndDeviceIdentifiers) {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Page != that1.Page {
		return false
	}
	if !this.FieldMask.Equal(&that1.FieldMask) {
		return false
	}
	return true
}
func (this *SetApplicationPackageAssociationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SetApplicationPackageAssociationRequest)
	if !ok {
		that2, ok := that.(SetApplicationPackageAssociationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ApplicationPackageAssociation.Equal(&that1.ApplicationPackageAssociation) {
		return false
	}
	if !this.FieldMask.Equal(&that1.FieldMask) {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ApplicationPackageRegistryClient is the client API for ApplicationPackageRegistry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ApplicationPackageRegistryClient interface {
	// List returns the available packages for the end device.
	List(ctx context.Context, in *EndDeviceIdentifiers, opts ...grpc.CallOption) (*ApplicationPackages, error)
	// Get returns the application package association registered on the FPort of the end device.
	GetAssociation(ctx context.Context, in *GetApplicationPackageAssociationRequest, opts ...grpc.CallOption) (*ApplicationPackageAssociation, error)
	// ListAssociations returns all of the application package associations of the end device.
	ListAssociations(ctx context.Context, in *ListApplicationPackageAssociationRequest, opts ...grpc.CallOption) (*ApplicationPackageAssociations, error)
	// SetAssociation updates or creates the application package association on the FPort of the end device.
	SetAssociation(ctx context.Context, in *SetApplicationPackageAssociationRequest, opts ...grpc.CallOption) (*ApplicationPackageAssociation, error)
	// DeleteAssociation removes the application package association on the FPort of the end device.
	DeleteAssociation(ctx context.Context, in *ApplicationPackageAssociationIdentifiers, opts ...grpc.CallOption) (*types.Empty, error)
}

type applicationPackageRegistryClient struct {
	cc *grpc.ClientConn
}

func NewApplicationPackageRegistryClient(cc *grpc.ClientConn) ApplicationPackageRegistryClient {
	return &applicationPackageRegistryClient{cc}
}

func (c *applicationPackageRegistryClient) List(ctx context.Context, in *EndDeviceIdentifiers, opts ...grpc.CallOption) (*ApplicationPackages, error) {
	out := new(ApplicationPackages)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.ApplicationPackageRegistry/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationPackageRegistryClient) GetAssociation(ctx context.Context, in *GetApplicationPackageAssociationRequest, opts ...grpc.CallOption) (*ApplicationPackageAssociation, error) {
	out := new(ApplicationPackageAssociation)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.ApplicationPackageRegistry/GetAssociation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationPackageRegistryClient) ListAssociations(ctx context.Context, in *ListApplicationPackageAssociationRequest, opts ...grpc.CallOption) (*ApplicationPackageAssociations, error) {
	out := new(ApplicationPackageAssociations)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.ApplicationPackageRegistry/ListAssociations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationPackageRegistryClient) SetAssociation(ctx context.Context, in *SetApplicationPackageAssociationRequest, opts ...grpc.CallOption) (*ApplicationPackageAssociation, error) {
	out := new(ApplicationPackageAssociation)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.ApplicationPackageRegistry/SetAssociation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationPackageRegistryClient) DeleteAssociation(ctx context.Context, in *ApplicationPackageAssociationIdentifiers, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.ApplicationPackageRegistry/DeleteAssociation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApplicationPackageRegistryServer is the server API for ApplicationPackageRegistry service.
type ApplicationPackageRegistryServer interface {
	// List returns the available packages for the end device.
	List(context.Context, *EndDeviceIdentifiers) (*ApplicationPackages, error)
	// Get returns the application package association registered on the FPort of the end device.
	GetAssociation(context.Context, *GetApplicationPackageAssociationRequest) (*ApplicationPackageAssociation, error)
	// ListAssociations returns all of the application package associations of the end device.
	ListAssociations(context.Context, *ListApplicationPackageAssociationRequest) (*ApplicationPackageAssociations, error)
	// SetAssociation updates or creates the application package association on the FPort of the end device.
	SetAssociation(context.Context, *SetApplicationPackageAssociationRequest) (*ApplicationPackageAssociation, error)
	// DeleteAssociation removes the application package association on the FPort of the end device.
	DeleteAssociation(context.Context, *ApplicationPackageAssociationIdentifiers) (*types.Empty, error)
}

// UnimplementedApplicationPackageRegistryServer can be embedded to have forward compatible implementations.
type UnimplementedApplicationPackageRegistryServer struct {
}

func (*UnimplementedApplicationPackageRegistryServer) List(ctx context.Context, req *EndDeviceIdentifiers) (*ApplicationPackages, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (*UnimplementedApplicationPackageRegistryServer) GetAssociation(ctx context.Context, req *GetApplicationPackageAssociationRequest) (*ApplicationPackageAssociation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAssociation not implemented")
}
func (*UnimplementedApplicationPackageRegistryServer) ListAssociations(ctx context.Context, req *ListApplicationPackageAssociationRequest) (*ApplicationPackageAssociations, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAssociations not implemented")
}
func (*UnimplementedApplicationPackageRegistryServer) SetAssociation(ctx context.Context, req *SetApplicationPackageAssociationRequest) (*ApplicationPackageAssociation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAssociation not implemented")
}
func (*UnimplementedApplicationPackageRegistryServer) DeleteAssociation(ctx context.Context, req *ApplicationPackageAssociationIdentifiers) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAssociation not implemented")
}

func RegisterApplicationPackageRegistryServer(s *grpc.Server, srv ApplicationPackageRegistryServer) {
	s.RegisterService(&_ApplicationPackageRegistry_serviceDesc, srv)
}

func _ApplicationPackageRegistry_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndDeviceIdentifiers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationPackageRegistryServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.ApplicationPackageRegistry/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationPackageRegistryServer).List(ctx, req.(*EndDeviceIdentifiers))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationPackageRegistry_GetAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetApplicationPackageAssociationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationPackageRegistryServer).GetAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.ApplicationPackageRegistry/GetAssociation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationPackageRegistryServer).GetAssociation(ctx, req.(*GetApplicationPackageAssociationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationPackageRegistry_ListAssociations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListApplicationPackageAssociationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationPackageRegistryServer).ListAssociations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.ApplicationPackageRegistry/ListAssociations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationPackageRegistryServer).ListAssociations(ctx, req.(*ListApplicationPackageAssociationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationPackageRegistry_SetAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetApplicationPackageAssociationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationPackageRegistryServer).SetAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.ApplicationPackageRegistry/SetAssociation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationPackageRegistryServer).SetAssociation(ctx, req.(*SetApplicationPackageAssociationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationPackageRegistry_DeleteAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationPackageAssociationIdentifiers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationPackageRegistryServer).DeleteAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.ApplicationPackageRegistry/DeleteAssociation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationPackageRegistryServer).DeleteAssociation(ctx, req.(*ApplicationPackageAssociationIdentifiers))
	}
	return interceptor(ctx, in, info, handler)
}

var _ApplicationPackageRegistry_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ttn.lorawan.v3.ApplicationPackageRegistry",
	HandlerType: (*ApplicationPackageRegistryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _ApplicationPackageRegistry_List_Handler,
		},
		{
			MethodName: "GetAssociation",
			Handler:    _ApplicationPackageRegistry_GetAssociation_Handler,
		},
		{
			MethodName: "ListAssociations",
			Handler:    _ApplicationPackageRegistry_ListAssociations_Handler,
		},
		{
			MethodName: "SetAssociation",
			Handler:    _ApplicationPackageRegistry_SetAssociation_Handler,
		},
		{
			MethodName: "DeleteAssociation",
			Handler:    _ApplicationPackageRegistry_DeleteAssociation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lorawan-stack/api/applicationserver_packages.proto",
}

func (m *ApplicationPackage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationPackage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplicationPackage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultFPort != 0 {
		i = encodeVarintApplicationserverPackages(dAtA, i, uint64(m.DefaultFPort))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApplicationserverPackages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApplicationPackages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationPackages) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplicationPackages) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Packages) > 0 {
		for iNdEx := len(m.Packages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Packages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApplicationserverPackages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ApplicationPackageAssociationIdentifiers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationPackageAssociationIdentifiers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplicationPackageAssociationIdentifiers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FPort != 0 {
		i = encodeVarintApplicationserverPackages(dAtA, i, uint64(m.FPort))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.EndDeviceIdentifiers.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApplicationserverPackages(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ApplicationPackageAssociation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationPackageAssociation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplicationPackageAssociation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApplicationserverPackages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PackageName) > 0 {
		i -= len(m.PackageName)
		copy(dAtA[i:], m.PackageName)
		i = encodeVarintApplicationserverPackages(dAtA, i, uint64(len(m.PackageName)))
		i--
		dAtA[i] = 0x22
	}
	n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdatedAt):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintApplicationserverPackages(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x1a
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintApplicationserverPackages(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ApplicationPackageAssociationIdentifiers.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApplicationserverPackages(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ApplicationPackageAssociations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationPackageAssociations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplicationPackageAssociations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Associations) > 0 {
		for iNdEx := len(m.Associations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Associations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApplicationserverPackages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetApplicationPackageAssociationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetApplicationPackageAssociationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetApplicationPackageAssociationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FieldMask.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApplicationserverPackages(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ApplicationPackageAssociationIdentifiers.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApplicationserverPackages(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListApplicationPackageAssociationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListApplicationPackageAssociationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListApplicationPackageAssociationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FieldMask.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApplicationserverPackages(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.Page != 0 {
		i = encodeVarintApplicationserverPackages(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x18
	}
	if m.Limit != 0 {
		i = encodeVarintApplicationserverPackages(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.EndDeviceIdentifiers.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApplicationserverPackages(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SetApplicationPackageAssociationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetApplicationPackageAssociationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetApplicationPackageAssociationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FieldMask.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApplicationserverPackages(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ApplicationPackageAssociation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApplicationserverPackages(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintApplicationserverPackages(dAtA []byte, offset int, v uint64) int {
	offset -= sovApplicationserverPackages(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedApplicationPackage(r randyApplicationserverPackages, easy bool) *ApplicationPackage {
	this := &ApplicationPackage{}
	this.Name = randStringApplicationserverPackages(r)
	this.DefaultFPort = r.Uint32()
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedApplicationPackages(r randyApplicationserverPackages, easy bool) *ApplicationPackages {
	this := &ApplicationPackages{}
	if r.Intn(5) != 0 {
		v1 := r.Intn(5)
		this.Packages = make([]*ApplicationPackage, v1)
		for i := 0; i < v1; i++ {
			this.Packages[i] = NewPopulatedApplicationPackage(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedApplicationPackageAssociationIdentifiers(r randyApplicationserverPackages, easy bool) *ApplicationPackageAssociationIdentifiers {
	this := &ApplicationPackageAssociationIdentifiers{}
	v2 := NewPopulatedEndDeviceIdentifiers(r, easy)
	this.EndDeviceIdentifiers = *v2
	this.FPort = r.Uint32()
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedApplicationPackageAssociation(r randyApplicationserverPackages, easy bool) *ApplicationPackageAssociation {
	this := &ApplicationPackageAssociation{}
	v3 := NewPopulatedApplicationPackageAssociationIdentifiers(r, easy)
	this.ApplicationPackageAssociationIdentifiers = *v3
	v4 := github_com_gogo_protobuf_types.NewPopulatedStdTime(r, easy)
	this.CreatedAt = *v4
	v5 := github_com_gogo_protobuf_types.NewPopulatedStdTime(r, easy)
	this.UpdatedAt = *v5
	this.PackageName = randStringApplicationserverPackages(r)
	if r.Intn(5) != 0 {
		this.Data = types.NewPopulatedStruct(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedApplicationPackageAssociations(r randyApplicationserverPackages, easy bool) *ApplicationPackageAssociations {
	this := &ApplicationPackageAssociations{}
	if r.Intn(5) != 0 {
		v6 := r.Intn(5)
		this.Associations = make([]*ApplicationPackageAssociation, v6)
		for i := 0; i < v6; i++ {
			this.Associations[i] = NewPopulatedApplicationPackageAssociation(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetApplicationPackageAssociationRequest(r randyApplicationserverPackages, easy bool) *GetApplicationPackageAssociationRequest {
	this := &GetApplicationPackageAssociationRequest{}
	v7 := NewPopulatedApplicationPackageAssociationIdentifiers(r, easy)
	this.ApplicationPackageAssociationIdentifiers = *v7
	v8 := types.NewPopulatedFieldMask(r, easy)
	this.FieldMask = *v8
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedListApplicationPackageAssociationRequest(r randyApplicationserverPackages, easy bool) *ListApplicationPackageAssociationRequest {
	this := &ListApplicationPackageAssociationRequest{}
	v9 := NewPopulatedEndDeviceIdentifiers(r, easy)
	this.EndDeviceIdentifiers = *v9
	this.Limit = r.Uint32()
	this.Page = r.Uint32()
	v10 := types.NewPopulatedFieldMask(r, easy)
	this.FieldMask = *v10
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSetApplicationPackageAssociationRequest(r randyApplicationserverPackages, easy bool) *SetApplicationPackageAssociationRequest {
	this := &SetApplicationPackageAssociationRequest{}
	v11 := NewPopulatedApplicationPackageAssociation(r, easy)
	this.ApplicationPackageAssociation = *v11
	v12 := types.NewPopulatedFieldMask(r, easy)
	this.FieldMask = *v12
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyApplicationserverPackages interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneApplicationserverPackages(r randyApplicationserverPackages) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringApplicationserverPackages(r randyApplicationserverPackages) string {
	v13 := r.Intn(100)
	tmps := make([]rune, v13)
	for i := 0; i < v13; i++ {
		tmps[i] = randUTF8RuneApplicationserverPackages(r)
	}
	return string(tmps)
}
func randUnrecognizedApplicationserverPackages(r randyApplicationserverPackages, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldApplicationserverPackages(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldApplicationserverPackages(dAtA []byte, r randyApplicationserverPackages, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateApplicationserverPackages(dAtA, uint64(key))
		v14 := r.Int63()
		if r.Intn(2) == 0 {
			v14 *= -1
		}
		dAtA = encodeVarintPopulateApplicationserverPackages(dAtA, uint64(v14))
	case 1:
		dAtA = encodeVarintPopulateApplicationserverPackages(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateApplicationserverPackages(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateApplicationserverPackages(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateApplicationserverPackages(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateApplicationserverPackages(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(v&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *ApplicationPackage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApplicationserverPackages(uint64(l))
	}
	if m.DefaultFPort != 0 {
		n += 1 + sovApplicationserverPackages(uint64(m.DefaultFPort))
	}
	return n
}

func (m *ApplicationPackages) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Packages) > 0 {
		for _, e := range m.Packages {
			l = e.Size()
			n += 1 + l + sovApplicationserverPackages(uint64(l))
		}
	}
	return n
}

func (m *ApplicationPackageAssociationIdentifiers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.EndDeviceIdentifiers.Size()
	n += 1 + l + sovApplicationserverPackages(uint64(l))
	if m.FPort != 0 {
		n += 1 + sovApplicationserverPackages(uint64(m.FPort))
	}
	return n
}

func (m *ApplicationPackageAssociation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ApplicationPackageAssociationIdentifiers.Size()
	n += 1 + l + sovApplicationserverPackages(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovApplicationserverPackages(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovApplicationserverPackages(uint64(l))
	l = len(m.PackageName)
	if l > 0 {
		n += 1 + l + sovApplicationserverPackages(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovApplicationserverPackages(uint64(l))
	}
	return n
}

func (m *ApplicationPackageAssociations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Associations) > 0 {
		for _, e := range m.Associations {
			l = e.Size()
			n += 1 + l + sovApplicationserverPackages(uint64(l))
		}
	}
	return n
}

func (m *GetApplicationPackageAssociationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ApplicationPackageAssociationIdentifiers.Size()
	n += 1 + l + sovApplicationserverPackages(uint64(l))
	l = m.FieldMask.Size()
	n += 1 + l + sovApplicationserverPackages(uint64(l))
	return n
}

func (m *ListApplicationPackageAssociationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.EndDeviceIdentifiers.Size()
	n += 1 + l + sovApplicationserverPackages(uint64(l))
	if m.Limit != 0 {
		n += 1 + sovApplicationserverPackages(uint64(m.Limit))
	}
	if m.Page != 0 {
		n += 1 + sovApplicationserverPackages(uint64(m.Page))
	}
	l = m.FieldMask.Size()
	n += 1 + l + sovApplicationserverPackages(uint64(l))
	return n
}

func (m *SetApplicationPackageAssociationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ApplicationPackageAssociation.Size()
	n += 1 + l + sovApplicationserverPackages(uint64(l))
	l = m.FieldMask.Size()
	n += 1 + l + sovApplicationserverPackages(uint64(l))
	return n
}

func sovApplicationserverPackages(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApplicationserverPackages(x uint64) (n int) {
	return sovApplicationserverPackages((x << 1) ^ uint64((int64(x) >> 63)))
}
func (this *ApplicationPackage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApplicationPackage{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`DefaultFPort:` + fmt.Sprintf("%v", this.DefaultFPort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApplicationPackages) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPackages := "[]*ApplicationPackage{"
	for _, f := range this.Packages {
		repeatedStringForPackages += strings.Replace(f.String(), "ApplicationPackage", "ApplicationPackage", 1) + ","
	}
	repeatedStringForPackages += "}"
	s := strings.Join([]string{`&ApplicationPackages{`,
		`Packages:` + repeatedStringForPackages + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApplicationPackageAssociationIdentifiers) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApplicationPackageAssociationIdentifiers{`,
		`EndDeviceIdentifiers:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.EndDeviceIdentifiers), "EndDeviceIdentifiers", "EndDeviceIdentifiers", 1), `&`, ``, 1) + `,`,
		`FPort:` + fmt.Sprintf("%v", this.FPort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApplicationPackageAssociation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApplicationPackageAssociation{`,
		`ApplicationPackageAssociationIdentifiers:` + strings.Replace(strings.Replace(this.ApplicationPackageAssociationIdentifiers.String(), "ApplicationPackageAssociationIdentifiers", "ApplicationPackageAssociationIdentifiers", 1), `&`, ``, 1) + `,`,
		`CreatedAt:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`UpdatedAt:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`PackageName:` + fmt.Sprintf("%v", this.PackageName) + `,`,
		`Data:` + strings.Replace(fmt.Sprintf("%v", this.Data), "Struct", "types.Struct", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApplicationPackageAssociations) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAssociations := "[]*ApplicationPackageAssociation{"
	for _, f := range this.Associations {
		repeatedStringForAssociations += strings.Replace(f.String(), "ApplicationPackageAssociation", "ApplicationPackageAssociation", 1) + ","
	}
	repeatedStringForAssociations += "}"
	s := strings.Join([]string{`&ApplicationPackageAssociations{`,
		`Associations:` + repeatedStringForAssociations + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetApplicationPackageAssociationRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetApplicationPackageAssociationRequest{`,
		`ApplicationPackageAssociationIdentifiers:` + strings.Replace(strings.Replace(this.ApplicationPackageAssociationIdentifiers.String(), "ApplicationPackageAssociationIdentifiers", "ApplicationPackageAssociationIdentifiers", 1), `&`, ``, 1) + `,`,
		`FieldMask:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.FieldMask), "FieldMask", "types.FieldMask", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListApplicationPackageAssociationRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListApplicationPackageAssociationRequest{`,
		`EndDeviceIdentifiers:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.EndDeviceIdentifiers), "EndDeviceIdentifiers", "EndDeviceIdentifiers", 1), `&`, ``, 1) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Page:` + fmt.Sprintf("%v", this.Page) + `,`,
		`FieldMask:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.FieldMask), "FieldMask", "types.FieldMask", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SetApplicationPackageAssociationRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SetApplicationPackageAssociationRequest{`,
		`ApplicationPackageAssociation:` + strings.Replace(strings.Replace(this.ApplicationPackageAssociation.String(), "ApplicationPackageAssociation", "ApplicationPackageAssociation", 1), `&`, ``, 1) + `,`,
		`FieldMask:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.FieldMask), "FieldMask", "types.FieldMask", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringApplicationserverPackages(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ApplicationPackage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApplicationserverPackages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationPackage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationPackage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFPort", wireType)
			}
			m.DefaultFPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultFPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApplicationserverPackages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplicationPackages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApplicationserverPackages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationPackages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationPackages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Packages = append(m.Packages, &ApplicationPackage{})
			if err := m.Packages[len(m.Packages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApplicationserverPackages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplicationPackageAssociationIdentifiers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApplicationserverPackages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationPackageAssociationIdentifiers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationPackageAssociationIdentifiers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDeviceIdentifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndDeviceIdentifiers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FPort", wireType)
			}
			m.FPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApplicationserverPackages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplicationPackageAssociation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApplicationserverPackages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationPackageAssociation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationPackageAssociation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationPackageAssociationIdentifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ApplicationPackageAssociationIdentifiers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &types.Struct{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApplicationserverPackages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplicationPackageAssociations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApplicationserverPackages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationPackageAssociations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationPackageAssociations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Associations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Associations = append(m.Associations, &ApplicationPackageAssociation{})
			if err := m.Associations[len(m.Associations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApplicationserverPackages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetApplicationPackageAssociationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApplicationserverPackages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetApplicationPackageAssociationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetApplicationPackageAssociationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationPackageAssociationIdentifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ApplicationPackageAssociationIdentifiers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FieldMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApplicationserverPackages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListApplicationPackageAssociationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApplicationserverPackages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListApplicationPackageAssociationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListApplicationPackageAssociationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDeviceIdentifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndDeviceIdentifiers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FieldMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApplicationserverPackages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetApplicationPackageAssociationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApplicationserverPackages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetApplicationPackageAssociationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetApplicationPackageAssociationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationPackageAssociation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ApplicationPackageAssociation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FieldMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApplicationserverPackages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApplicationserverPackages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApplicationserverPackages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApplicationserverPackages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApplicationserverPackages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApplicationserverPackages
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApplicationserverPackages
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApplicationserverPackages
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApplicationserverPackages        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApplicationserverPackages          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApplicationserverPackages = fmt.Errorf("proto: unexpected end of group")
)
