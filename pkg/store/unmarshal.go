// Copyright Â© 2017 The Things Network Foundation, distributed under the MIT license (see LICENSE file)

package store

import (
	"strings"

	"github.com/mitchellh/mapstructure"
)

func unflattened(m map[string]interface{}) map[string]interface{} {
	out := make(map[string]interface{}, len(m))
	for k, v := range m {
		skeys := strings.Split(k, ".")
		parent := out
		for _, sk := range skeys[:len(skeys)-1] {
			sm, ok := parent[sk]
			if !ok {
				sm = make(map[string]interface{})
				parent[sk] = sm
			}
			parent = sm.(map[string]interface{})
		}
		parent[skeys[len(skeys)-1]] = v
	}
	return out
}

// MapUnmarshaler is the interface implemented by an object that can
// unmarshal a map[string]interface{} representation of itself.
//
// UnmarshalMap must be able to decode the form generated by MarshalMap.
// UnmarshalMap must deep copy the data if it wishes to retain the data
// after returning.
type MapUnmarshaler interface {
	UnmarshalMap(map[string]interface{}) error
}

// Unmarshal parses the map-encoded data and stores the result
// in the value pointed to by v.
//
// Unmarshal uses the inverse of the encodings that
// Marshal uses.
func Unmarshal(m map[string]interface{}, v interface{}) error {
	switch t := v.(type) {
	case MapUnmarshaler:
		return t.UnmarshalMap(m)
	case map[string]interface{}:
		for k, v := range unflattened(m) {
			t[k] = v
		}
		return nil
	default:
		return mapstructure.Decode(unflattened(m), v)
	}
}
