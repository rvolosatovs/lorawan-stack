// Copyright Â© 2018 The Things Network Foundation, distributed under the MIT license (see LICENSE file)

package store

import (
	"encoding"
	"encoding/json"
	"reflect"
	"strconv"
	"strings"

	"github.com/TheThingsNetwork/ttn/pkg/errors"
	"github.com/gogo/protobuf/jsonpb"
	"github.com/gogo/protobuf/proto"
	"github.com/mitchellh/mapstructure"
)

// slicify recursively replaces (sub-)maps in m by slices.
func slicify(m map[string]interface{}) interface{} {
	for k, v := range m {
		sm, ok := v.(map[string]interface{})
		if ok {
			v = slicify(sm)
			m[k] = v
		}
	}

	sl := make([]interface{}, len(m))
	for k, v := range m {
		i, err := strconv.Atoi(k)
		if err != nil {
			return m
		}
		if len(sl) <= i {
			sl = append(sl, make([]interface{}, 1+i-len(sl))...)
		}
		sl[i] = v
	}
	return sl
}

func unflattened(m map[string]interface{}) map[string]interface{} {
	out := make(map[string]interface{}, len(m))
	for k, v := range m {
		skeys := strings.Split(k, Separator)
		parent := out
		for _, sk := range skeys[:len(skeys)-1] {
			sm, ok := parent[sk]
			if !ok {
				sm = make(map[string]interface{})
				parent[sk] = sm
			}
			parent = sm.(map[string]interface{})
		}
		parent[skeys[len(skeys)-1]] = v
	}
	return out
}

func isByteSlice(t reflect.Type) bool {
	return t.Kind() == reflect.Slice && t.Elem().Kind() == reflect.Uint8
}

func fromBytesHookFunc(f reflect.Type, t reflect.Type, v interface{}) (interface{}, error) {
	if isByteSlice(f) && !isByteSlice(t) {
		return bytesToType(v.([]byte), t)
	}
	return v, nil
}

var mapUnmarshalerType = reflect.TypeOf((*MapUnmarshaler)(nil)).Elem()

func toInterfaceHookFunc(f reflect.Type, t reflect.Type, v interface{}) (interface{}, error) {
	if f.Kind() == reflect.Map && f.Elem().Kind() == reflect.Interface &&
		t.Implements(mapUnmarshalerType) && !(t.Kind() == reflect.Interface || t.Kind() == reflect.Ptr && t.Elem().Kind() == reflect.Interface) {
		out := reflect.New(t).Interface().(MapUnmarshaler)
		return out, out.UnmarshalMap(v.(map[string]interface{}))
	}
	return v, nil
}

// MapUnmarshaler is the interface implemented by an object that can
// unmarshal a map[string]interface{} representation of itself.
//
// UnmarshalMap must be able to decode the form generated by MarshalMap.
// UnmarshalMap must deep copy the data if it wishes to retain the data
// after returning.
type MapUnmarshaler interface {
	UnmarshalMap(map[string]interface{}) error
}

// UnmarshalMap parses the map-encoded data and stores the result
// in the value pointed to by v.
//
// UnmarshalMap uses the inverse of the encodings that
// Marshal uses.
func UnmarshalMap(m map[string]interface{}, v interface{}, hooks ...mapstructure.DecodeHookFunc) error {
	m = unflattened(m)
	switch t := v.(type) {
	case MapUnmarshaler:
		return t.UnmarshalMap(m)
	default:
		if len(m) == 0 {
			return nil
		}
		conf := &mapstructure.DecoderConfig{
			WeaklyTypedInput: true,
			ZeroFields:       true,
			Result:           v,
			DecodeHook: mapstructure.ComposeDecodeHookFunc(append(
				hooks,
				toInterfaceHookFunc,
				fromBytesHookFunc,
			)...),
		}

		dec, err := mapstructure.NewDecoder(conf)
		if err != nil {
			panic(errors.NewWithCause("Failed to intialize decoder", err))
		}
		return dec.Decode(slicify(m))
	}
}

func typeByFlatName(typ reflect.Type, name string) (reflect.Type, bool) {
	if name == "" {
		panic(errors.New("Empty name specified"))
	}
	for _, name := range strings.Split(name, Separator) {
		if typ.Kind() == reflect.Ptr {
			typ = typ.Elem()
		}
		switch typ.Kind() {
		case reflect.Struct:
			f, ok := typ.FieldByName(name)
			if !ok {
				return nil, false
			}
			typ = f.Type
		case reflect.Slice, reflect.Array:
			typ = typ.Elem()
		case reflect.Map:
			typ = typ.Key()
		default:
			return nil, false
		}
	}
	return typ, true
}

var jsonpbUnmarshaler = &jsonpb.Unmarshaler{}

var (
	encodingBinaryUnmarshalerType = reflect.TypeOf((*encoding.BinaryUnmarshaler)(nil)).Elem()
	encodingTextUnmarshalerType   = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()
	protoUnmarshalerType          = reflect.TypeOf((*proto.Unmarshaler)(nil)).Elem()
	jsonUnmarshalerType           = reflect.TypeOf((*json.Unmarshaler)(nil)).Elem()
	jsonpbJSONPBUnmarshalerType   = reflect.TypeOf((*jsonpb.JSONPBUnmarshaler)(nil)).Elem()
)

func bytesToType(b []byte, typ reflect.Type) (interface{}, error) {
	if typ.Kind() == reflect.Ptr {
		typ = typ.Elem()
	}

	if typ.Kind() == reflect.Interface {
		return nil, errors.New("Can not decode into an interface value")
	}

	enc := Encoding(b[0])
	b = b[1:]
	if len(b) == 0 {
		return reflect.New(typ).Elem().Interface(), nil
	}

	switch enc {
	case RawEncoding:
		switch k := typ.Kind(); k {
		case reflect.String:
			return string(b), nil
		case reflect.Bool:
			return strconv.ParseBool(string(b))
		case reflect.Int:
			return strconv.ParseInt(string(b), 10, 64)
		case reflect.Int8:
			return strconv.ParseInt(string(b), 10, 8)
		case reflect.Int16:
			return strconv.ParseInt(string(b), 10, 16)
		case reflect.Int32:
			return strconv.ParseInt(string(b), 10, 32)
		case reflect.Int64:
			return strconv.ParseInt(string(b), 10, 64)
		case reflect.Uint:
			return strconv.ParseUint(string(b), 10, 64)
		case reflect.Uint8:
			return strconv.ParseUint(string(b), 10, 8)
		case reflect.Uint16:
			return strconv.ParseUint(string(b), 10, 16)
		case reflect.Uint32:
			return strconv.ParseUint(string(b), 10, 32)
		case reflect.Uint64:
			return strconv.ParseUint(string(b), 10, 64)
		case reflect.Float32:
			return strconv.ParseFloat(string(b), 32)
		case reflect.Float64:
			return strconv.ParseFloat(string(b), 64)
		case reflect.Slice, reflect.Array:
			elem := typ.Elem()
			if elem.Kind() == reflect.Uint8 {
				// Handle byte slices/arrays directly
				if k == reflect.Slice {
					return b, nil
				}
				rv := reflect.Indirect(reflect.New(typ))
				for i := 0; i < rv.Len(); i++ {
					rv.Index(i).SetUint(uint64(b[i]))
				}
				return rv.Interface(), nil
			}
		}
		return nil, errors.Errorf("can not decode raw bytes to value of type %s", typ)
	case BinaryEncoding:
		if !reflect.PtrTo(typ).Implements(encodingBinaryUnmarshalerType) {
			return nil, errors.Errorf("expected %s to implement %s", typ, encodingBinaryUnmarshalerType)
		}
		v := reflect.New(typ).Interface().(encoding.BinaryUnmarshaler)
		return v, v.UnmarshalBinary(b)
	case TextEncoding:
		if !reflect.PtrTo(typ).Implements(encodingTextUnmarshalerType) {
			return nil, errors.Errorf("expected %s to implement %s", typ, encodingTextUnmarshalerType)
		}
		v := reflect.New(typ).Interface().(encoding.TextUnmarshaler)
		return v, v.UnmarshalText(b)
	case ProtoEncoding:
		if !reflect.PtrTo(typ).Implements(protoUnmarshalerType) {
			return nil, errors.Errorf("expected %s to implement %s", typ, protoUnmarshalerType)
		}
		v := reflect.New(typ).Interface().(proto.Unmarshaler)
		return v, v.Unmarshal(b)
	case JSONEncoding:
		if !reflect.PtrTo(typ).Implements(jsonUnmarshalerType) {
			return nil, errors.Errorf("expected %s to implement %s", typ, jsonUnmarshalerType)
		}
		v := reflect.New(typ).Interface().(json.Unmarshaler)
		return v, v.UnmarshalJSON(b)
	case JSONPBEncoding:
		if !reflect.PtrTo(typ).Implements(jsonpbJSONPBUnmarshalerType) {
			return nil, errors.Errorf("expected %s to implement %s", typ, jsonpbJSONPBUnmarshalerType)
		}
		v := reflect.New(typ).Interface().(jsonpb.JSONPBUnmarshaler)
		return v, v.UnmarshalJSONPB(jsonpbUnmarshaler, b)
	case UnknownEncoding:
		return nil, errors.New("value is encoded using unknown encoding")
	default:
		return nil, errors.New("invalid data")
	}
}

// UnmarshalByteMap parses the byte map-encoded data and stores the result
// in the value pointed to by v.
//
// UnmarshalByteMap uses the inverse of the encodings that
// MarshalByteMap uses.
func UnmarshalByteMap(bm map[string][]byte, v interface{}, hooks ...mapstructure.DecodeHookFunc) error {
	typ := reflect.TypeOf(v)
	if typ.Kind() == reflect.Ptr {
		typ = typ.Elem()
	}

	im := make(map[string]interface{}, len(bm))
	switch typ.Kind() {
	case reflect.Struct:
		for k, bv := range bm {
			it, ok := typeByFlatName(typ, k)
			if !ok {
				return errors.Errorf("field %s does not exist on type specified", k)
			}
			iv, err := bytesToType(bv, it)
			if err != nil {
				return err
			}
			im[k] = iv
		}
	default:
		panic(errors.Errorf("UnmarshalByteMap: %s is not supported yet", typ))
	}
	return UnmarshalMap(im, v)
}
