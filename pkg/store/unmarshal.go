// Copyright Â© 2018 The Things Network Foundation, distributed under the MIT license (see LICENSE file)

package store

import (
	"encoding"
	"encoding/json"
	"reflect"
	"strconv"
	"strings"

	"github.com/TheThingsNetwork/ttn/pkg/errors"
	"github.com/gogo/protobuf/jsonpb"
	"github.com/gogo/protobuf/proto"
	"github.com/mitchellh/mapstructure"
)

// Slicify recursively replaces (sub-)maps(generated by Mapify) in m by slices.
func Slicify(m map[string]interface{}) interface{} {
	for k, v := range m {
		sm, ok := v.(map[string]interface{})
		if ok {
			v = Slicify(sm)
			m[k] = v
		}
	}

	sl := make([]interface{}, len(m))
	for k, v := range m {
		i, err := strconv.Atoi(k)
		if err != nil {
			return m
		}
		if len(sl) <= i {
			sl = append(sl, make([]interface{}, 1+i-len(sl))...)
		}
		sl[i] = v
	}
	return sl
}

// Unflattened unflattens m and returns the result
func Unflattened(m map[string]interface{}) map[string]interface{} {
	out := make(map[string]interface{}, len(m))
	for k, v := range m {
		skeys := strings.Split(k, Separator)
		parent := out
		for _, sk := range skeys[:len(skeys)-1] {
			sm, ok := parent[sk]
			if !ok {
				sm = make(map[string]interface{})
				parent[sk] = sm
			}
			parent = sm.(map[string]interface{})
		}
		parent[skeys[len(skeys)-1]] = v
	}
	return out
}

func isByteSlice(t reflect.Type) bool {
	return t.Kind() == reflect.Slice && t.Elem().Kind() == reflect.Uint8
}

func fromBytesHookFuncRaw(f reflect.Type, t reflect.Type, v interface{}) (interface{}, error) {
	if isByteSlice(f) {
		return BytesToType(v.([]byte), t)
	}
	return v, nil
}

func fromBytesHookFuncTyped(f reflect.Type, t reflect.Type, v interface{}) (interface{}, error) {
	if isByteSlice(f) && !isByteSlice(t) {
		return BytesToType(v.([]byte), t)
	}
	return v, nil
}

var mapUnmarshalerType = reflect.TypeOf((*MapUnmarshaler)(nil)).Elem()

func mapUnmarshalerHookFunc(f reflect.Type, t reflect.Type, v interface{}) (interface{}, error) {
	switch {
	case t.Kind() == reflect.Interface,
		t.Kind() == reflect.Ptr && t.Elem().Kind() == reflect.Interface,
		f.Kind() != reflect.Map:
	case t.Implements(mapUnmarshalerType):
		out := reflect.New(t.Elem()).Interface().(MapUnmarshaler)
		return out, out.UnmarshalMap(v.(map[string]interface{}))
	case reflect.PtrTo(t).Implements(mapUnmarshalerType):
		out := reflect.New(t).Interface().(MapUnmarshaler)
		return out, out.UnmarshalMap(v.(map[string]interface{}))
	}
	return v, nil
}

func interfaceMapToByteMap(im map[string]interface{}) (bm map[string][]byte, ok bool) {
	bm = make(map[string][]byte, len(im))
	for k, v := range im {
		bm[k], ok = v.([]byte)
		if !ok {
			return nil, false
		}
	}
	return
}

var byteMapUnmarshalerType = reflect.TypeOf((*ByteMapUnmarshaler)(nil)).Elem()

func byteMapUnmarshalerHookFunc(f reflect.Type, t reflect.Type, v interface{}) (interface{}, error) {
	switch {
	case t.Kind() == reflect.Interface,
		t.Kind() == reflect.Ptr && t.Elem().Kind() == reflect.Interface,
		f.Kind() != reflect.Map:
	case t.Implements(byteMapUnmarshalerType):
		out := reflect.New(t.Elem()).Interface().(ByteMapUnmarshaler)
		bm, ok := interfaceMapToByteMap(v.(map[string]interface{}))
		if !ok {
			return nil, errors.New("Mismatched hook")
		}
		return out, out.UnmarshalByteMap(bm)
	case reflect.PtrTo(t).Implements(byteMapUnmarshalerType):
		out := reflect.New(t).Interface().(ByteMapUnmarshaler)
		bm, ok := interfaceMapToByteMap(v.(map[string]interface{}))
		if !ok {
			return nil, errors.New("Mismatched hook")
		}
		return out, out.UnmarshalByteMap(bm)
	}
	return v, nil
}

var emptyInterfaceType = reflect.TypeOf((*interface{})(nil)).Elem()

func skipInterfaceHook(f reflect.Type, t reflect.Type, v interface{}) (interface{}, error) {
	if t.Kind() == reflect.Interface && t != emptyInterfaceType {
		return nil, errors.Errorf("Impossible to decode into %s, which is an interface type", t)
	}
	return v, nil
}

// MapUnmarshaler is the interface implemented by an object that can
// unmarshal a map[string]interface{} representation of itself.
//
// UnmarshalMap must be able to decode the form generated by MarshalMap.
// UnmarshalMap must deep copy the data if it wishes to retain the data after returning.
type MapUnmarshaler interface {
	UnmarshalMap(map[string]interface{}) error
}

// UnmarshalMap parses the map-encoded data and stores the result
// in the value pointed to by v.
//
// UnmarshalMap uses the inverse of the encodings that
// Marshal uses.
func UnmarshalMap(m map[string]interface{}, v interface{}, hooks ...mapstructure.DecodeHookFunc) error {
	if mu, ok := v.(MapUnmarshaler); ok {
		return mu.UnmarshalMap(m)
	}

	if len(m) == 0 {
		return nil
	}

	dec, err := mapstructure.NewDecoder(&mapstructure.DecoderConfig{
		WeaklyTypedInput: true,
		ZeroFields:       true,
		Result:           v,
		DecodeHook: mapstructure.ComposeDecodeHookFunc(append(
			hooks,
			skipInterfaceHook,
			mapUnmarshalerHookFunc,
			fromBytesHookFuncTyped,
		)...),
	})
	if err != nil {
		panic(errors.NewWithCause("Failed to intialize decoder", err))
	}
	return dec.Decode(Slicify(Unflattened(m)).(map[string]interface{}))
}

var jsonpbUnmarshaler = &jsonpb.Unmarshaler{}

var (
	encodingBinaryUnmarshalerType = reflect.TypeOf((*encoding.BinaryUnmarshaler)(nil)).Elem()
	encodingTextUnmarshalerType   = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()
	protoUnmarshalerType          = reflect.TypeOf((*proto.Unmarshaler)(nil)).Elem()
	jsonUnmarshalerType           = reflect.TypeOf((*json.Unmarshaler)(nil)).Elem()
	jsonpbJSONPBUnmarshalerType   = reflect.TypeOf((*jsonpb.JSONPBUnmarshaler)(nil)).Elem()
)

func BytesToType(b []byte, typ reflect.Type) (interface{}, error) {
	if typ.Kind() == reflect.Ptr {
		typ = typ.Elem()
	}

	if typ.Kind() == reflect.Interface {
		return nil, errors.New("Can not decode into an interface value")
	}

	enc := Encoding(b[0])
	b = b[1:]
	if len(b) == 0 {
		return reflect.New(typ).Elem().Interface(), nil
	}

	switch enc {
	case RawEncoding:
		switch k := typ.Kind(); k {
		case reflect.String:
			return string(b), nil
		case reflect.Bool:
			return strconv.ParseBool(string(b))
		case reflect.Int:
			return strconv.ParseInt(string(b), 10, 64)
		case reflect.Int8:
			return strconv.ParseInt(string(b), 10, 8)
		case reflect.Int16:
			return strconv.ParseInt(string(b), 10, 16)
		case reflect.Int32:
			return strconv.ParseInt(string(b), 10, 32)
		case reflect.Int64:
			return strconv.ParseInt(string(b), 10, 64)
		case reflect.Uint:
			return strconv.ParseUint(string(b), 10, 64)
		case reflect.Uint8:
			return strconv.ParseUint(string(b), 10, 8)
		case reflect.Uint16:
			return strconv.ParseUint(string(b), 10, 16)
		case reflect.Uint32:
			return strconv.ParseUint(string(b), 10, 32)
		case reflect.Uint64:
			return strconv.ParseUint(string(b), 10, 64)
		case reflect.Float32:
			return strconv.ParseFloat(string(b), 32)
		case reflect.Float64:
			return strconv.ParseFloat(string(b), 64)
		case reflect.Slice, reflect.Array:
			elem := typ.Elem()
			if elem.Kind() == reflect.Uint8 {
				// Handle byte slices/arrays directly
				if k == reflect.Slice {
					return b, nil
				}
				rv := reflect.Indirect(reflect.New(typ))
				for i := 0; i < rv.Len(); i++ {
					rv.Index(i).SetUint(uint64(b[i]))
				}
				return rv.Interface(), nil
			}
		}
		return nil, errors.Errorf("can not decode raw bytes to value of type %s", typ)
	case BinaryEncoding:
		if !reflect.PtrTo(typ).Implements(encodingBinaryUnmarshalerType) {
			return nil, errors.Errorf("expected %s to implement %s", typ, encodingBinaryUnmarshalerType)
		}
		v := reflect.New(typ).Interface().(encoding.BinaryUnmarshaler)
		return v, v.UnmarshalBinary(b)
	case TextEncoding:
		if !reflect.PtrTo(typ).Implements(encodingTextUnmarshalerType) {
			return nil, errors.Errorf("expected %s to implement %s", typ, encodingTextUnmarshalerType)
		}
		v := reflect.New(typ).Interface().(encoding.TextUnmarshaler)
		return v, v.UnmarshalText(b)
	case ProtoEncoding:
		if !reflect.PtrTo(typ).Implements(protoUnmarshalerType) {
			return nil, errors.Errorf("expected %s to implement %s", typ, protoUnmarshalerType)
		}
		v := reflect.New(typ).Interface().(proto.Unmarshaler)
		return v, v.Unmarshal(b)
	case JSONEncoding:
		if !reflect.PtrTo(typ).Implements(jsonUnmarshalerType) {
			return nil, errors.Errorf("expected %s to implement %s", typ, jsonUnmarshalerType)
		}
		v := reflect.New(typ).Interface().(json.Unmarshaler)
		return v, v.UnmarshalJSON(b)
	case JSONPBEncoding:
		if !reflect.PtrTo(typ).Implements(jsonpbJSONPBUnmarshalerType) {
			return nil, errors.Errorf("expected %s to implement %s", typ, jsonpbJSONPBUnmarshalerType)
		}
		v := reflect.New(typ).Interface().(jsonpb.JSONPBUnmarshaler)
		return v, v.UnmarshalJSONPB(jsonpbUnmarshaler, b)
	case UnknownEncoding:
		return nil, errors.New("Value is encoded using unknown encoding")
	default:
		return nil, errors.New("Invalid data")
	}
}

// ByteMapUnmarshaler is the interface implemented by an object that can
// unmarshal a map[string][]byte representation of itself.
//
// UnmarshalByteMap must be able to decode the form generated by MarshalByteMap.
// UnmarshalByteMap must deep copy the data if it wishes to retain the data after returning.
type ByteMapUnmarshaler interface {
	UnmarshalByteMap(map[string][]byte) error
}

// UnmarshalByteMap parses the byte map-encoded data and stores the result in the value pointed to by v.
// UnmarshalByteMap uses the inverse of the encodings that MarshalByteMap uses.
func UnmarshalByteMap(bm map[string][]byte, v interface{}, hooks ...mapstructure.DecodeHookFunc) error {
	if mm, ok := v.(ByteMapUnmarshaler); ok {
		return mm.UnmarshalByteMap(bm)
	}

	if len(bm) == 0 {
		return nil
	}

	im := make(map[string]interface{}, len(bm))
	for k, v := range bm {
		im[k] = v
	}

	dec, err := mapstructure.NewDecoder(&mapstructure.DecoderConfig{
		WeaklyTypedInput: true,
		ZeroFields:       true,
		Result:           v,
		DecodeHook: mapstructure.ComposeDecodeHookFunc(append(
			hooks,
			skipInterfaceHook,
			byteMapUnmarshalerHookFunc,
			fromBytesHookFuncRaw,
		)...),
	})
	if err != nil {
		panic(errors.NewWithCause("Failed to intialize decoder", err))
	}
	return dec.Decode(Slicify(Unflattened(im)).(map[string]interface{}))
}
