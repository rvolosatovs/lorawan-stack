// Copyright Â© 2018 The Things Network Foundation, distributed under the MIT license (see LICENSE file)

package store

import (
	"bytes"
	"encoding/gob"
	"encoding/json"
	"reflect"
	"strings"

	"github.com/TheThingsNetwork/ttn/pkg/errors"
	"github.com/gogo/protobuf/proto"
	"github.com/mitchellh/mapstructure"
)

var (
	mapUnmarshalerType     = reflect.TypeOf((*MapUnmarshaler)(nil)).Elem()
	protoUnmarshalerType   = reflect.TypeOf((*proto.Unmarshaler)(nil)).Elem()
	jsonUnmarshalerType    = reflect.TypeOf((*json.Unmarshaler)(nil)).Elem()
	byteMapUnmarshalerType = reflect.TypeOf((*ByteMapUnmarshaler)(nil)).Elem()
)

// Unflattened unflattens m and returns the result
func Unflattened(m map[string]interface{}) map[string]interface{} {
	out := make(map[string]interface{}, len(m))
	for k, v := range m {
		skeys := strings.Split(k, Separator)
		parent := out
		for _, sk := range skeys[:len(skeys)-1] {
			sm, ok := parent[sk]
			if !ok {
				sm = make(map[string]interface{})
				parent[sk] = sm
			}
			parent = sm.(map[string]interface{})
		}
		parent[skeys[len(skeys)-1]] = v
	}
	return out
}

func isNillableKind(k reflect.Kind) bool {
	return k == reflect.Ptr ||
		k == reflect.Map ||
		k == reflect.Interface ||
		k == reflect.Chan ||
		k == reflect.Func ||
		k == reflect.Slice
}

func isNillable(t reflect.Type) bool {
	return isNillableKind(t.Kind())
}

// MapUnmarshaler is the interface implemented by an object that can
// unmarshal a map[string]interface{} representation of itself.
//
// UnmarshalMap must be able to decode the form generated by MarshalMap.
// UnmarshalMap must deep copy the data if it wishes to retain the data after returning.
type MapUnmarshaler interface {
	UnmarshalMap(map[string]interface{}) error
}

// UnmarshalMap parses the map-encoded data and stores the result
// in the value pointed to by v.
//
// UnmarshalMap uses the inverse of the encodings that
// Marshal uses.
func UnmarshalMap(m map[string]interface{}, v interface{}, hooks ...mapstructure.DecodeHookFunc) error {
	if mu, ok := v.(MapUnmarshaler); ok {
		return mu.UnmarshalMap(m)
	}

	if len(m) == 0 {
		return nil
	}

	rv := reflect.ValueOf(v)
	for rv.Kind() == reflect.Ptr && rv.IsValid() {
		rv = rv.Elem()
	}
	if !rv.IsValid() {
		return ErrInvalidData.NewWithCause(nil, errors.Errorf("Indirected value is nil"))
	}

	for mk, mv := range m {
		skeys := strings.Split(mk, Separator)

		fv := rv
		for _, sk := range skeys {
			for fv.Kind() == reflect.Ptr {
				if fv.IsNil() {
					fv.Set(reflect.New(fv.Type().Elem()))
				}
				fv = fv.Elem()
			}
			if fv = fv.FieldByName(sk); !fv.IsValid() {
				return errors.Errorf("Field `%s` specified, but does not exist on structs of type `%s`", sk, fv.Type())
			}
		}

		rmv := reflect.ValueOf(mv)
		switch vk := rmv.Kind(); vk {
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
			reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
			reflect.Float32, reflect.Float64, reflect.Bool, reflect.String:
			if vk != fv.Kind() {
				return ErrInvalidData.NewWithCause(nil, errors.Errorf("Field value `%s` has kind `%s`, when `%s` is expected", mk, fv.Kind(), vk))
			}
			fv.Set(rmv)

		case reflect.Invalid:
			continue

		case reflect.Slice:
			if rmv.Type().Elem().Kind() == reflect.Uint8 {
				iv, err := BytesToType(rmv.Bytes(), fv.Type())
				if err != nil {
					return err
				}
				if iv != nil {
					fv.Set(reflect.ValueOf(iv))
				}
				continue
			}
			fallthrough

		default:
			return ErrInvalidData.NewWithCause(nil, errors.Errorf("Unmatched map value kind: `%s`", vk))
		}
	}
	return nil
}

// BytesToType decodes []byte value in b into a new value of type typ.
func BytesToType(b []byte, typ reflect.Type) (interface{}, error) {
	if len(b) == 0 {
		if !isNillable(typ) {
			return nil, ErrInvalidData.NewWithCause(nil, errors.Errorf("Type `%s` is not nullable, but zero-length byte slice specified", typ))
		}
		return nil, nil
	}

	enc := Encoding(b[0])
	b = b[1:]

	rv := reflect.New(typ)
	e := rv.Elem()
	for e.Kind() == reflect.Ptr {
		e.Set(reflect.New(e.Type().Elem()))
		e = e.Elem()
	}

	switch e.Kind() {
	case reflect.Slice:
		e.Set(reflect.MakeSlice(e.Type(), 0, 0))
	case reflect.Map:
		e.Set(reflect.MakeMap(e.Type()))
	case reflect.Chan:
		e.Set(reflect.MakeChan(e.Type(), 0))
	case reflect.Func:
		e.Set(reflect.MakeFunc(e.Type(), func([]reflect.Value) []reflect.Value { return nil }))
	}

	switch enc {
	case JSONEncoding:
		if typ.Implements(jsonUnmarshalerType) {
			v := rv.Elem().Interface().(json.Unmarshaler)
			return v, v.UnmarshalJSON(b)
		}
		if reflect.PtrTo(typ).Implements(jsonUnmarshalerType) {
			if err := rv.Interface().(json.Unmarshaler).UnmarshalJSON(b); err != nil {
				return nil, err
			}
			return rv.Elem().Interface(), nil
		}
		return nil, errors.Errorf("Expected %s or %s to implement %s", typ, reflect.PtrTo(typ), jsonUnmarshalerType)
	case ProtoEncoding:
		if typ.Implements(protoUnmarshalerType) {
			v := rv.Elem().Interface().(proto.Unmarshaler)
			return v, v.Unmarshal(b)
		}
		if reflect.PtrTo(typ).Implements(protoUnmarshalerType) {
			if err := rv.Interface().(proto.Unmarshaler).Unmarshal(b); err != nil {
				return nil, err
			}
			return rv.Elem().Interface(), nil
		}
		return nil, errors.Errorf("Expected %s or %s to implement %s", typ, reflect.PtrTo(typ), protoUnmarshalerType)
	case GobEncoding:
		if err := gob.NewDecoder(bytes.NewReader(b)).DecodeValue(rv.Elem()); err != nil {
			return nil, err
		}
		return rv.Elem().Interface(), nil
	default:
		return nil, ErrInvalidData.NewWithCause(nil, errors.Errorf("Unmatched encoding"))
	}
}

// ByteMapUnmarshaler is the interface implemented by an object that can
// unmarshal a map[string][]byte representation of itself.
//
// UnmarshalByteMap must be able to decode the form generated by MarshalByteMap.
// UnmarshalByteMap must deep copy the data if it wishes to retain the data after returning.
type ByteMapUnmarshaler interface {
	UnmarshalByteMap(map[string][]byte) error
}

// UnmarshalByteMap parses the byte map-encoded data and stores the result in the value pointed to by v.
// UnmarshalByteMap uses the inverse of the encodings that MarshalByteMap uses.
func UnmarshalByteMap(bm map[string][]byte, v interface{}, hooks ...mapstructure.DecodeHookFunc) error {
	if mm, ok := v.(ByteMapUnmarshaler); ok {
		return mm.UnmarshalByteMap(bm)
	}

	if len(bm) == 0 {
		return nil
	}

	im := make(map[string]interface{}, len(bm))
	for k, v := range bm {
		im[k] = v
	}

	return UnmarshalMap(im, v)
}
