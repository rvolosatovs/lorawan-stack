// Copyright Â© 2017 The Things Network Foundation, distributed under the MIT license (see LICENSE file)

package store

import (
	"encoding"
	"encoding/json"
	"reflect"
	"strconv"
	"strings"

	"github.com/TheThingsNetwork/ttn/pkg/errors"
	"github.com/gogo/protobuf/proto"
	"github.com/mitchellh/mapstructure"
)

func unflattened(m map[string]interface{}) map[string]interface{} {
	out := make(map[string]interface{}, len(m))
	for k, v := range m {
		skeys := strings.Split(k, Separator)
		parent := out
		for _, sk := range skeys[:len(skeys)-1] {
			sm, ok := parent[sk]
			if !ok {
				sm = make(map[string]interface{})
				parent[sk] = sm
			}
			parent = sm.(map[string]interface{})
		}
		parent[skeys[len(skeys)-1]] = v
	}
	return out
}

// MapUnmarshaler is the interface implemented by an object that can
// unmarshal a map[string]interface{} representation of itself.
//
// UnmarshalMap must be able to decode the form generated by MarshalMap.
// UnmarshalMap must deep copy the data if it wishes to retain the data
// after returning.
type MapUnmarshaler interface {
	UnmarshalMap(map[string]interface{}) error
}

// UnmarshalMap parses the map-encoded data and stores the result
// in the value pointed to by v.
//
// UnmarshalMap uses the inverse of the encodings that
// Marshal uses.
func UnmarshalMap(m map[string]interface{}, v interface{}) error {
	switch t := v.(type) {
	case MapUnmarshaler:
		return t.UnmarshalMap(m)
	case map[string]interface{}:
		for k, v := range unflattened(m) {
			t[k] = v
		}
		return nil
	default:
		return mapstructure.Decode(unflattened(m), v)
	}
}

func fieldByFlatName(typ reflect.Type, name string) (f reflect.StructField, ok bool) {
	if name == "" {
		panic(errors.New("github.com/TheThingsNetwork/ttn/pkg/store.fieldByFlatName: empty name specified"))
	}
	for _, name := range strings.Split(name, Separator) {
		f, ok = typ.FieldByName(name)
		if !ok {
			break
		}
		typ = f.Type
	}
	return f, ok
}

func bytesToType(b []byte, typ reflect.Type) (interface{}, error) {
	if typ.Kind() == reflect.Ptr {
		typ = typ.Elem()
	}

	enc := Encoding(b[0])
	b = b[1:]

	switch enc {
	case RawEncoding:
		switch k := typ.Kind(); k {
		case reflect.String:
			return string(b), nil
		case reflect.Bool:
			return strconv.ParseBool(string(b))
		case reflect.Int:
			return strconv.ParseInt(string(b), 10, 64)
		case reflect.Int8:
			return strconv.ParseInt(string(b), 10, 8)
		case reflect.Int16:
			return strconv.ParseInt(string(b), 10, 16)
		case reflect.Int32:
			return strconv.ParseInt(string(b), 10, 32)
		case reflect.Int64:
			return strconv.ParseInt(string(b), 10, 64)
		case reflect.Uint:
			return strconv.ParseUint(string(b), 10, 64)
		case reflect.Uint8:
			return strconv.ParseUint(string(b), 10, 8)
		case reflect.Uint16:
			return strconv.ParseUint(string(b), 10, 16)
		case reflect.Uint32:
			return strconv.ParseUint(string(b), 10, 32)
		case reflect.Uint64:
			return strconv.ParseUint(string(b), 10, 64)
		case reflect.Float32:
			return strconv.ParseFloat(string(b), 32)
		case reflect.Float64:
			return strconv.ParseFloat(string(b), 64)
		case reflect.Slice, reflect.Array:
			elem := typ.Elem()
			if elem.Kind() == reflect.Uint8 {
				// Handle byte slices/arrays directly
				if k == reflect.Slice {
					return b, nil
				}
				rv := reflect.Indirect(reflect.New(typ))
				for i := 0; i < rv.Len(); i++ {
					rv.Index(i).SetUint(uint64(b[i]))
				}
				return rv.Interface(), nil
			}
		}
		return nil, errors.Errorf("can not decode raw bytes to value of type %s", typ)
	case BinaryEncoding:
		v, ok := reflect.New(typ).Interface().(encoding.BinaryUnmarshaler)
		if !ok {
			var expected encoding.BinaryUnmarshaler
			return nil, errors.Errorf("expected %s to implement %T", typ, expected)
		}
		return v, v.UnmarshalBinary(b)
	case TextEncoding:
		v, ok := reflect.New(typ).Interface().(encoding.TextUnmarshaler)
		if !ok {
			var expected encoding.TextUnmarshaler
			return nil, errors.Errorf("expected %s to implement %T", typ, expected)
		}
		return v, v.UnmarshalText(b)
	case ProtoEncoding:
		v, ok := reflect.New(typ).Interface().(proto.Unmarshaler)
		if !ok {
			var expected proto.Unmarshaler
			return nil, errors.Errorf("expected %s to implement %T", typ, expected)
		}
		return v, v.Unmarshal(b)
	case JSONEncoding:
		v, ok := reflect.New(typ).Interface().(json.Unmarshaler)
		if !ok {
			var expected json.Unmarshaler
			return nil, errors.Errorf("expected %s to implement %T", typ, expected)
		}
		return v, v.UnmarshalJSON(b)
	case UnknownEncoding:
		return nil, errors.New("value is encoded using unknown encoding")
	default:
		return nil, errors.New("invalid data")
	}
}

// UnmarshalByteMap parses the byte map-encoded data and stores the result
// in the value pointed to by v.
//
// UnmarshalByteMap uses the inverse of the encodings that
// MarshalByteMap uses.
func UnmarshalByteMap(bm map[string][]byte, v interface{}) error {
	typ := reflect.TypeOf(v)
	if typ.Kind() == reflect.Ptr {
		typ = typ.Elem()
	}

	im := make(map[string]interface{}, len(bm))
	switch typ.Kind() {
	case reflect.Struct:
		for k, bv := range bm {
			f, ok := fieldByFlatName(typ, k)
			if !ok {
				return errors.Errorf("field %s does not exist on type specified", k)
			}
			iv, err := bytesToType(bv, f.Type)
			if err != nil {
				return err
			}
			im[k] = iv
		}
	default:
		panic(errors.Errorf("UnmarshalByteMap: %s is not supported yet", typ))
	}
	return UnmarshalMap(im, v)
}
