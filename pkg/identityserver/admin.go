// Copyright Â© 2018 The Things Network Foundation, distributed under the MIT license (see LICENSE file)

package identityserver

import (
	"context"
	"strings"
	"time"

	"github.com/TheThingsNetwork/ttn/pkg/errors"
	"github.com/TheThingsNetwork/ttn/pkg/identityserver/email/templates"
	"github.com/TheThingsNetwork/ttn/pkg/identityserver/store"
	"github.com/TheThingsNetwork/ttn/pkg/identityserver/store/sql"
	"github.com/TheThingsNetwork/ttn/pkg/identityserver/util"
	"github.com/TheThingsNetwork/ttn/pkg/random"
	"github.com/TheThingsNetwork/ttn/pkg/ttnpb"
	pbtypes "github.com/gogo/protobuf/types"
)

type adminService struct {
	*IdentityServer
}

// GetSettings fetches the current dynamic settings of the Identity Server.
func (s *adminService) GetSettings(ctx context.Context, _ *pbtypes.Empty) (*ttnpb.IdentityServerSettings, error) {
	err := s.enforceAdmin(ctx)
	if err != nil {
		return nil, err
	}

	return s.store.Settings.Get()
}

// UpdateSettings updates the dynamic settings.
func (s *adminService) UpdateSettings(ctx context.Context, req *ttnpb.UpdateSettingsRequest) (*pbtypes.Empty, error) {
	if err := s.enforceAdmin(ctx); err != nil {
		return nil, err
	}

	settings, err := s.store.Settings.Get()
	if err != nil {
		return nil, err
	}

	for _, path := range req.UpdateMask.Paths {
		switch {
		case ttnpb.FieldPathSettingsBlacklistedIDs.MatchString(path):
			if req.Settings.BlacklistedIDs == nil {
				req.Settings.BlacklistedIDs = []string{}
			}
			settings.BlacklistedIDs = req.Settings.BlacklistedIDs
		case ttnpb.FieldPathSettingsUserRegistrationSkipValidation.MatchString(path):
			settings.SkipValidation = req.Settings.SkipValidation
		case ttnpb.FieldPathSettingsUserRegistrationSelfRegistration.MatchString(path):
			settings.SelfRegistration = req.Settings.SelfRegistration
		case ttnpb.FieldPathSettingsUserRegistrationAdminApproval.MatchString(path):
			settings.AdminApproval = req.Settings.AdminApproval
		case ttnpb.FieldPathSettingsValidationTokenTTL.MatchString(path):
			settings.ValidationTokenTTL = req.Settings.ValidationTokenTTL
		case ttnpb.FieldPathSettingsAllowedEmails.MatchString(path):
			if req.Settings.AllowedEmails == nil {
				req.Settings.AllowedEmails = []string{}
			}
			settings.AllowedEmails = req.Settings.AllowedEmails
		case ttnpb.FieldPathSettingsInvitationTokenTTL.MatchString(path):
			settings.InvitationTokenTTL = req.Settings.InvitationTokenTTL
		default:
			return nil, ttnpb.ErrInvalidPathUpdateMask.New(errors.Attributes{
				"path": path,
			})
		}
	}

	return nil, s.store.Settings.Set(settings)
}

// CreateUser creates an account on behalf of an user. A password is generated
// and sent to the user's email.
func (s *adminService) CreateUser(ctx context.Context, req *ttnpb.CreateUserRequest) (*pbtypes.Empty, error) {
	err := s.enforceAdmin(ctx)
	if err != nil {
		return nil, err
	}

	// set an autogenerated password
	req.User.Password = random.String(8)

	// mark user as approved
	req.User.State = ttnpb.STATE_APPROVED

	var token string
	err = s.store.Transact(func(st *store.Store) error {
		settings, err := st.Settings.Get()
		if err != nil {
			return err
		}

		if settings.SkipValidation {
			req.User.ValidatedAt = time.Now().UTC()
		}

		err = st.Users.Create(&req.User)
		if err != nil {
			return err
		}

		// if validation can be skipped just finish transaction
		if settings.SkipValidation {
			return nil
		}

		// otherwise create a token and save it
		token = random.String(64)

		return st.Users.SaveValidationToken(req.User.UserID, &store.ValidationToken{
			ValidationToken: token,
			CreatedAt:       time.Now(),
			ExpiresIn:       int32(settings.ValidationTokenTTL.Seconds()),
		})
	})

	if err != nil {
		return nil, err
	}

	return nil, s.email.Send(req.User.Email, &templates.AccountCreation{
		OrganizationName: s.config.OrganizationName,
		PublicURL:        s.config.PublicURL,
		Name:             req.User.Name,
		UserID:           req.User.UserID,
		Password:         req.User.Password,
		ValidationToken:  token,
	})
}

// GetUser returns an user account.
func (s *adminService) GetUser(ctx context.Context, req *ttnpb.UserIdentifier) (*ttnpb.User, error) {
	err := s.enforceAdmin(ctx)
	if err != nil {
		return nil, err
	}

	found, err := s.store.Users.GetByID(req.UserID, s.factories.user)
	if err != nil {
		return nil, err
	}
	found.GetUser().Password = ""

	return found.GetUser(), nil
}

// ListUsers returns a list of users with optional filtering.
func (s *adminService) ListUsers(ctx context.Context, req *ttnpb.ListUsersRequest) (*ttnpb.ListUsersResponse, error) {
	err := s.enforceAdmin(ctx)
	if err != nil {
		return nil, err
	}

	users, err := s.store.Users.List(s.factories.user)
	if err != nil {
		return nil, err
	}

	resp := &ttnpb.ListUsersResponse{
		Users: make([]*ttnpb.User, 0, len(users)),
	}

	// filter results manually
	for _, user := range users {
		u := user.GetUser()

		switch filter := req.ListUsersRequest_FilterState; filter {
		case nil:
		default:
			if u.State != filter.State {
				continue
			}
		}

		resp.Users = append(resp.Users, u)
	}

	return resp, nil
}

// UpdateUser updates the account of the current user.
// If the email is modified a validation email will be sent.
func (s *adminService) UpdateUser(ctx context.Context, req *ttnpb.UpdateUserRequest) (*pbtypes.Empty, error) {
	err := s.enforceAdmin(ctx)
	if err != nil {
		return nil, err
	}

	found, err := s.store.Users.GetByID(req.User.UserID, s.factories.user)
	if err != nil {
		return nil, err
	}

	settings, err := s.store.Settings.Get()
	if err != nil {
		return nil, err
	}

	newEmail := false
	for _, path := range req.UpdateMask.Paths {
		switch {
		case ttnpb.FieldPathUserAdmin.MatchString(path):
			found.GetUser().Admin = req.User.Admin
		case ttnpb.FieldPathUserState.MatchString(path):
			found.GetUser().State = req.User.State
		case ttnpb.FieldPathUserName.MatchString(path):
			found.GetUser().Name = req.User.Name
		case ttnpb.FieldPathUserEmail.MatchString(path):
			if strings.ToLower(req.User.Email) != strings.ToLower(found.GetUser().Email) {
				newEmail = true
				found.GetUser().ValidatedAt = time.Time{}
			}

			if !util.IsEmailAllowed(req.User.Email, settings.AllowedEmails) {
				return nil, ErrEmailAddressNotAllowed.New(errors.Attributes{
					"email":          req.User.Email,
					"allowed_emails": settings.AllowedEmails,
				})
			}

			found.GetUser().Email = req.User.Email
		default:
			return nil, ttnpb.ErrInvalidPathUpdateMask.New(errors.Attributes{
				"path": path,
			})
		}
	}

	if !newEmail {
		return nil, s.store.Users.Update(found)
	}

	err = s.store.Transact(func(st *store.Store) error {
		err := st.Users.Update(found)
		if err != nil {
			return err
		}

		token := &store.ValidationToken{
			ValidationToken: random.String(64),
			CreatedAt:       time.Now(),
			ExpiresIn:       int32(settings.ValidationTokenTTL.Seconds()),
		}

		err = st.Users.SaveValidationToken(req.User.UserID, token)
		if err != nil {
			return err
		}

		return s.email.Send(found.GetUser().Email, &templates.EmailValidation{
			OrganizationName: s.config.OrganizationName,
			PublicURL:        s.config.PublicURL,
			Token:            token.ValidationToken,
		})
	})

	return nil, err
}

// ResetUserPassword sets an autogenerated password to an user and sends it to
// the user's email.
func (s *adminService) ResetUserPassword(ctx context.Context, req *ttnpb.UserIdentifier) (*pbtypes.Empty, error) {
	err := s.enforceAdmin(ctx)
	if err != nil {
		return nil, err
	}

	found, err := s.store.Users.GetByID(req.UserID, s.factories.user)
	if err != nil {
		return nil, err
	}

	user := found.GetUser()
	user.Password = random.String(8)

	err = s.store.Users.Update(user)
	if err != nil {
		return nil, err
	}

	return nil, s.email.Send(user.Email, &templates.PasswordReset{
		OrganizationName: s.config.OrganizationName,
		PublicURL:        s.config.PublicURL,
		Password:         user.Password,
	})
}

// DeleteUser deletes an user.
func (s *adminService) DeleteUser(ctx context.Context, req *ttnpb.UserIdentifier) (*pbtypes.Empty, error) {
	err := s.enforceAdmin(ctx)
	if err != nil {
		return nil, err
	}

	found, err := s.store.Users.GetByID(req.UserID, s.factories.user)
	if err != nil {
		return nil, err
	}

	err = s.store.Users.Delete(req.UserID)
	if err != nil {
		return nil, err
	}

	return nil, s.email.Send(found.GetUser().Email, &templates.AccountDeleted{
		UserID:           req.UserID,
		OrganizationName: s.config.OrganizationName,
		PublicURL:        s.config.PublicURL,
	})
}

// SendInvitation sends by email a token that can be used to create a new account.
// All invitations are expirable and the TTL is defined on a setitngs variable.
func (s *adminService) SendInvitation(ctx context.Context, req *ttnpb.SendInvitationRequest) (*pbtypes.Empty, error) {
	err := s.enforceAdmin(ctx)
	if err != nil {
		return nil, err
	}

	// check whether email is already registered or not
	found, err := s.store.Users.GetByEmail(req.Email, s.factories.user)
	if err != nil && !sql.ErrUserEmailNotFound.Describes(err) {
		return nil, err
	}

	// if email is already being used return error
	if found != nil {
		return nil, ErrEmailAddressAlreadyUsed.New(errors.Attributes{
			"email": req.Email,
		})
	}

	// otherwise proceed to issue invitation
	settings, err := s.store.Settings.Get()
	if err != nil {
		return nil, err
	}

	now := time.Now().UTC()
	invitation := &store.InvitationData{
		Token:     random.String(64),
		Email:     req.Email,
		IssuedAt:  now,
		ExpiresAt: now.Add(settings.InvitationTokenTTL),
	}

	err = s.store.Invitations.Save(invitation)
	if err != nil {
		return nil, err
	}

	return nil, s.email.Send(req.Email, &templates.Invitation{
		OrganizationName: s.config.OrganizationName,
		PublicURL:        s.config.PublicURL,
		Token:            invitation.Token,
	})
}

// ListInvitations lists all the issued invitations.
func (s *adminService) ListInvitations(ctx context.Context, req *pbtypes.Empty) (*ttnpb.ListInvitationsResponse, error) {
	err := s.enforceAdmin(ctx)
	if err != nil {
		return nil, err
	}

	invitations, err := s.store.Invitations.List()
	if err != nil {
		return nil, err
	}

	resp := &ttnpb.ListInvitationsResponse{
		Invitations: make([]*ttnpb.ListInvitationsResponse_Invitation, 0, len(invitations)),
	}

	for _, invitation := range invitations {
		resp.Invitations = append(resp.Invitations, &ttnpb.ListInvitationsResponse_Invitation{
			Email:     invitation.Email,
			IssuedAt:  invitation.IssuedAt,
			ExpiresAt: invitation.ExpiresAt,
		})
	}

	return resp, nil
}

// DeleteInvitation revokes an unused invitation or deletes an expired one.
func (s *adminService) DeleteInvitation(ctx context.Context, req *ttnpb.DeleteInvitationRequest) (*pbtypes.Empty, error) {
	err := s.enforceAdmin(ctx)
	if err != nil {
		return nil, err
	}

	return nil, s.store.Invitations.Delete(req.Email)
}

// GetClient returns a client.
func (s *adminService) GetClient(ctx context.Context, req *ttnpb.ClientIdentifier) (*ttnpb.Client, error) {
	err := s.enforceAdmin(ctx)
	if err != nil {
		return nil, err
	}

	found, err := s.store.Clients.GetByID(req.ClientID, s.factories.client)
	if err != nil {
		return nil, err
	}

	return found.GetClient(), nil
}

// ListClients returns a list of third-party clients with optional filtering.
func (s *adminService) ListClients(ctx context.Context, req *ttnpb.ListClientsRequest) (*ttnpb.ListClientsResponse, error) {
	err := s.enforceAdmin(ctx)
	if err != nil {
		return nil, err
	}

	found, err := s.store.Clients.List(s.factories.client)
	if err != nil {
		return nil, err
	}

	resp := &ttnpb.ListClientsResponse{
		Clients: make([]*ttnpb.Client, 0, len(found)),
	}

	// filter results manually
	for _, client := range found {
		cli := client.GetClient()

		switch filter := req.ListClientsRequest_FilterState; filter {
		case nil:
		default:
			if cli.State != filter.State {
				continue
			}
		}

		resp.Clients = append(resp.Clients, cli)
	}

	return resp, nil
}

// UpdateClient updates a third-party client.
func (s *adminService) UpdateClient(ctx context.Context, req *ttnpb.UpdateClientRequest) (*pbtypes.Empty, error) {
	err := s.enforceAdmin(ctx)
	if err != nil {
		return nil, err
	}

	found, err := s.store.Clients.GetByID(req.Client.ClientID, s.factories.client)
	if err != nil {
		return nil, err
	}

	for _, path := range req.UpdateMask.Paths {
		switch {
		case ttnpb.FieldPathClientDescription.MatchString(path):
			found.GetClient().Description = req.Client.Description
		case ttnpb.FieldPathClientRedirectURI.MatchString(path):
			found.GetClient().RedirectURI = req.Client.RedirectURI
		case ttnpb.FieldPathClientRights.MatchString(path):
			if req.Client.Rights == nil {
				req.Client.Rights = []ttnpb.Right{}
			}
			found.GetClient().Rights = req.Client.Rights
		case ttnpb.FieldPathClientOfficialLabeled.MatchString(path):
			found.GetClient().OfficialLabeled = req.Client.OfficialLabeled
		case ttnpb.FieldPathClientState.MatchString(path):
			found.GetClient().State = req.Client.State
		case ttnpb.FieldPathClientGrants.MatchString(path):
			if req.Client.Grants == nil {
				req.Client.Grants = []ttnpb.GrantType{}
			}
			found.GetClient().Grants = req.Client.Grants
		default:
			return nil, ttnpb.ErrInvalidPathUpdateMask.New(errors.Attributes{
				"path": path,
			})
		}
	}

	return nil, s.store.Clients.Update(found)
}

// DeleteClient deletes a client and therefore all the user authorizations are revoked.
func (s *adminService) DeleteClient(ctx context.Context, req *ttnpb.ClientIdentifier) (*pbtypes.Empty, error) {
	err := s.enforceAdmin(ctx)
	if err != nil {
		return nil, err
	}

	found, err := s.store.Clients.GetByID(req.ClientID, s.factories.client)
	if err != nil {
		return nil, err
	}

	user, err := s.store.Users.GetByID(found.GetClient().Creator.UserID, s.factories.user)
	if err != nil {
		return nil, err
	}

	err = s.store.Clients.Delete(req.ClientID)
	if err != nil {
		return nil, err
	}

	return nil, s.email.Send(user.GetUser().Email, &templates.ClientDeleted{
		ClientID:         req.ClientID,
		OrganizationName: s.config.OrganizationName,
		PublicURL:        s.config.PublicURL,
	})
}
